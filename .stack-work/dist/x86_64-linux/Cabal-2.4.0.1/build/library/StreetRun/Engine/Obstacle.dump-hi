
==================== FINAL INTERFACE ====================
2019-04-25 16:33:26.69395434 UTC

interface street-runner-0.0.0-GEoHgSQZcIaHrT8BK7yHRE:StreetRun.Engine.Obstacle 8064
  interface hash: 1d6082bf071a5a878e9ac4e8015281d6
  ABI hash: 6d1cc93d569703a721f42ebf46a1a248
  export-list hash: 8447d39a129b8229a00392a91bd37c3b
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 23bfc2de71c0e795adcc3e64d97ecb08
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  StreetRun.Engine.Obstacle.birdY
  StreetRun.Engine.Obstacle.canAddObstacle
  StreetRun.Engine.Obstacle.iterateObstacles
  StreetRun.Engine.Obstacle.lastObstacleDistance
  StreetRun.Engine.Obstacle.lavaY
  StreetRun.Engine.Obstacle.obstacleAabb
  StreetRun.Engine.Obstacle.placeObstacle
  StreetRun.Engine.Obstacle.randomRBoundedEnum
  StreetRun.Engine.Obstacle.removeOutOfBoundObstacles
  StreetRun.Engine.Obstacle.rockY
  StreetRun.Engine.Obstacle.stepObstacles
  StreetRun.Engine.Obstacle.streamOfObstacles
  StreetRun.Engine.Obstacle.ObstacleInfo{StreetRun.Engine.Obstacle.ObstacleInfo'Bird StreetRun.Engine.Obstacle.ObstacleInfo'Lava StreetRun.Engine.Obstacle.ObstacleInfo'Rock}
  StreetRun.Engine.Obstacle.ObstacleState{StreetRun.Engine.Obstacle.ObstacleState osDistance osInfo}
  StreetRun.Engine.Obstacle.ObstacleTag{StreetRun.Engine.Obstacle.ObstacleTag'Bird StreetRun.Engine.Obstacle.ObstacleTag'Lava StreetRun.Engine.Obstacle.ObstacleTag'Rock}
module dependencies: StreetRun.Engine.Bird StreetRun.Engine.Lava
                     StreetRun.Engine.Physics StreetRun.Engine.Rock
                     StreetRun.Engine.Types
package dependencies: StateVar-1.1.1.1 adjunctions-4.4
                      aeson-1.4.2.0 animate-0.7.0 array-0.5.3.0 attoparsec-0.13.2.2
                      base-4.12.0.0 base-compat-0.10.5 base-orphans-0.8.1
                      bifunctors-5.5.3 binary-0.8.6.0 bytes-0.15.5 bytestring-0.10.8.2
                      call-stack-0.1.0 cereal-0.5.8.0 comonad-5.0.4 conduit-1.3.1.1
                      containers-0.6.0.1 contravariant-1.5 deepseq-1.4.4.0
                      distributive-0.6 dlist-0.8.0.6 exceptions-0.10.1 free-5.1
                      ghc-boot-th-8.6.4 ghc-prim-0.5.3 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.2.2 kan-extensions-5.2
                      lens-4.17 libyaml-0.1.1.0 linear-1.20.8 mtl-2.2.2 pretty-1.1.3.6
                      primitive-0.6.4.0 profunctors-5.3 random-1.1 reflection-2.1.4
                      resourcet-1.2.2 scientific-0.3.6.2 semigroupoids-5.3.2 stm-2.5.0.0
                      tagged-0.8.6 template-haskell-2.14.0.0 text-1.2.3.1
                      th-abstraction-0.2.11.0 time-1.8.0.2 time-locale-compat-0.1.1.5
                      transformers-0.5.6.2 transformers-base-0.4.5.2
                      transformers-compat-0.6.2 unliftio-core-0.1.2.0
                      unordered-containers-0.2.9.0 uuid-types-1.0.3 vector-0.12.0.2
                      yaml-0.11.0.0
orphans: attoparsec-0.13.2.2:Data.Attoparsec.Text.Internal
         attoparsec-0.13.2.2:Data.Attoparsec.ByteString.Char8
         time-1.8.0.2:Data.Time.Clock.TAI
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         reflection-2.1.4:Data.Reflection
         vector-0.12.0.2:Data.Vector.Unboxed stm-2.5.0.0:Control.Monad.STM
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show linear-1.20.8:Linear.Instances
         vector-0.12.0.2:Data.Vector.Fusion.Bundle
         transformers-0.5.6.2:Control.Monad.Trans.Error
         base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: adjunctions-4.4:Data.Functor.Rep
                         aeson-1.4.2.0:Data.Aeson.Types.Internal animate-0.7.0:Animate
                         attoparsec-0.13.2.2:Data.Attoparsec.Internal.Types
                         base-4.12.0.0:Control.Applicative base-4.12.0.0:Data.Complex
                         base-4.12.0.0:Data.Functor.Compose base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         bifunctors-5.5.3:Data.Bifunctor.Biff
                         bifunctors-5.5.3:Data.Bifunctor.Clown
                         bifunctors-5.5.3:Data.Bifunctor.Fix
                         bifunctors-5.5.3:Data.Bifunctor.Flip
                         bifunctors-5.5.3:Data.Bifunctor.Join
                         bifunctors-5.5.3:Data.Bifunctor.Joker
                         bifunctors-5.5.3:Data.Bifunctor.Product
                         bifunctors-5.5.3:Data.Bifunctor.Sum
                         bifunctors-5.5.3:Data.Bifunctor.Tannen
                         bifunctors-5.5.3:Data.Bifunctor.Wrapped bytes-0.15.5:Data.Bytes.Get
                         bytes-0.15.5:Data.Bytes.Signed bytes-0.15.5:Data.Bytes.VarInt
                         conduit-1.3.1.1:Data.Conduit.Internal.Conduit
                         conduit-1.3.1.1:Data.Conduit.Internal.Pipe
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         dlist-0.8.0.6:Data.DList free-5.1:Control.Comonad.Cofree
                         free-5.1:Control.Comonad.Trans.Cofree free-5.1:Control.Monad.Free
                         free-5.1:Control.Monad.Trans.Free
                         ghc-boot-th-8.6.4:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.4:GHC.LanguageExtensions.Type
                         kan-extensions-5.2:Data.Functor.Day
                         kan-extensions-5.2:Data.Functor.Yoneda lens-4.17:Control.Lens.At
                         lens-4.17:Control.Lens.Internal.Indexed
                         lens-4.17:Control.Lens.Reified lens-4.17:Control.Lens.Tuple
                         lens-4.17:Control.Lens.Wrapped lens-4.17:Control.Lens.Zoom
                         linear-1.20.8:Linear.Plucker linear-1.20.8:Linear.Quaternion
                         linear-1.20.8:Linear.V linear-1.20.8:Linear.V0
                         linear-1.20.8:Linear.V1 linear-1.20.8:Linear.V2
                         linear-1.20.8:Linear.V3 linear-1.20.8:Linear.V4
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         primitive-0.6.4.0:Data.Primitive.PrimArray
                         primitive-0.6.4.0:Data.Primitive.SmallArray
                         primitive-0.6.4.0:Data.Primitive.UnliftedArray
                         profunctors-5.3:Data.Profunctor.Composition
                         profunctors-5.3:Data.Profunctor.Rep
                         resourcet-1.2.2:Control.Monad.Trans.Resource.Internal
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         th-abstraction-0.2.11.0:Language.Haskell.TH.Datatype
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.2:Data.Vector vector-0.12.0.2:Data.Vector.Primitive
                         vector-0.12.0.2:Data.Vector.Storable
                         vector-0.12.0.2:Data.Vector.Unboxed
                         vector-0.12.0.2:Data.Vector.Unboxed.Base
import  -/  animate-0.7.0:Animate 7c6496232245300f888f7e0dafeb231c
import  -/  base-4.12.0.0:Data.Foldable 5f70351366640f007be66681d2212df8
import  -/  base-4.12.0.0:Data.Tuple c719fc29608fe81c10bee9a1bf1e05ff
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Enum 87204abed08db8735fc0be5ab48689aa
import  -/  base-4.12.0.0:GHC.Err ea5e313ef4146b40b5d8b27aa168e736
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:GHC.Real af2b985dd29515c375fb78b2c9298d42
import  -/  base-4.12.0.0:GHC.Show 838a5d039379d82d9626aae53dfce276
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  linear-1.20.8:Linear c66c613217f57f0236b62caf498b629a
import  -/  linear-1.20.8:Linear.V2 4a7e4c0c9247ec5477069840e3acbf22
import  -/  random-1.1:System.Random a2913fef910fa7846b8be540f8dcdaf5
import  -/  StreetRun.Engine.Bird 0bf40510f04513db7870a0eb83c839ab
  exports: 6e60076273bcfd5477b3f0cf8d1fb4b8
  BirdKey 6a9f4bb688ed79cdcb6a0a9ff040ea9c
  BirdKey'Idle 11a1ee3f2c3664611da8b27bd54bb55e
import  -/  StreetRun.Engine.Lava f12a1755c46bbf2df272aa84c51b192b
  exports: f674034831bb56a1796bab0274d25cf8
  LavaKey f25b5b950fa3119282ec4bccb43f6de6
  LavaKey'Idle df3eda6da760b77f140fa00cbab93359
import  -/  StreetRun.Engine.Physics 52ab0c4d5302ce013ba13455ebad6494
  exports: 354224f4972beeb3405c52a8946cdd1d
  Aabb 83e83c93911fa2299ed073ce28a8b5f0
  Aabb c8f90d7fb30835562641e7da9d0bca37
  arenaWidth b565ef67ffba404e6a984ef4c3c9de98
import  -/  StreetRun.Engine.Rock c3a73de49be33c068fbd58b6e1005240
  exports: 09a82b06dd827cf2307a7779ea2b3f72
  RockKey 1650d41f6fdcaf3574b8f2ff1544e6e1
  RockKey'Idle 19115d33ff9142dabd3be5528d76700a
import  -/  StreetRun.Engine.Types 6986db6c9f4d1e9fc0edc9e119b1c392
  exports: c934b5ae3d6a2dfd0319fd3b47efce61
  Distance 1d27617e6b1a52e1b2997bf23482db86
  Percent 34f2154fa29bed1ea1f6b21bbba55be5
  Seconds 970124013cb076e3574e853bf4f93243
9f0794044af3e60bc0f6840b3f4430f5
  $fBoundedObstacleTag ::
    GHC.Enum.Bounded StreetRun.Engine.Obstacle.ObstacleTag
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ StreetRun.Engine.Obstacle.ObstacleTag
                  StreetRun.Engine.Obstacle.ObstacleTag'Lava
                  StreetRun.Engine.Obstacle.ObstacleTag'Bird -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag ::
    GHC.Enum.Enum StreetRun.Engine.Obstacle.ObstacleTag
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ StreetRun.Engine.Obstacle.ObstacleTag
                  StreetRun.Engine.Obstacle.$fEnumObstacleTag_$csucc
                  StreetRun.Engine.Obstacle.$fEnumObstacleTag_$cpred
                  StreetRun.Engine.Obstacle.$fEnumObstacleTag_$ctoEnum
                  StreetRun.Engine.Obstacle.$fEnumObstacleTag_$cfromEnum
                  StreetRun.Engine.Obstacle.$fEnumObstacleTag_$cenumFrom
                  StreetRun.Engine.Obstacle.$fEnumObstacleTag_$cenumFromThen
                  StreetRun.Engine.Obstacle.$fEnumObstacleTag_$cenumFromTo
                  StreetRun.Engine.Obstacle.$fEnumObstacleTag_$cenumFromThenTo -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag1 :: [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Unfolding: (StreetRun.Engine.Obstacle.$fEnumObstacleTag_go3
                   2#) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag2 :: [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Unfolding: (StreetRun.Engine.Obstacle.$fEnumObstacleTag_go3
                   1#) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag3 :: [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Unfolding: (StreetRun.Engine.Obstacle.$fEnumObstacleTag_go3
                   0#) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag4 :: StreetRun.Engine.Obstacle.ObstacleTag
  {- Strictness: x -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag5 :: StreetRun.Engine.Obstacle.ObstacleTag
  {- Strictness: x -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag_$cenumFrom ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 case a of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava
                   -> StreetRun.Engine.Obstacle.$fEnumObstacleTag3
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock
                   -> StreetRun.Engine.Obstacle.$fEnumObstacleTag2
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird
                   -> StreetRun.Engine.Obstacle.$fEnumObstacleTag1 }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag_$cenumFromThen ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag
    -> [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag_$cenumFromThenTo ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag
    -> [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag_$cenumFromTo ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag
    -> [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (y :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 let {
                   $j :: GHC.Prim.Int# -> [StreetRun.Engine.Obstacle.ObstacleTag]
                     <join 1> {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       StreetRun.Engine.Obstacle.ObstacleTag'Lava
                       -> case GHC.Prim.># x1 0# of lwild {
                            DEFAULT -> StreetRun.Engine.Obstacle.$fEnumObstacleTag_go2 x1
                            1# -> GHC.Types.[] @ StreetRun.Engine.Obstacle.ObstacleTag }
                       StreetRun.Engine.Obstacle.ObstacleTag'Rock
                       -> case GHC.Prim.># x1 1# of lwild {
                            DEFAULT -> StreetRun.Engine.Obstacle.$fEnumObstacleTag_go1 x1
                            1# -> GHC.Types.[] @ StreetRun.Engine.Obstacle.ObstacleTag }
                       StreetRun.Engine.Obstacle.ObstacleTag'Bird
                       -> case GHC.Prim.># x1 2# of lwild {
                            DEFAULT -> StreetRun.Engine.Obstacle.$fEnumObstacleTag_go x1
                            1# -> GHC.Types.[] @ StreetRun.Engine.Obstacle.ObstacleTag } }
                 } in
                 case x of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava -> $j 0#
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock -> $j 1#
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird -> $j 2# }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag_$cfromEnum ::
    StreetRun.Engine.Obstacle.ObstacleTag -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 case a of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava -> GHC.Types.I# 0#
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock -> GHC.Types.I# 1#
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird -> GHC.Types.I# 2# }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag_$cpred ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 case a of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava
                   -> StreetRun.Engine.Obstacle.$fEnumObstacleTag4
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock
                   -> StreetRun.Engine.Obstacle.ObstacleTag'Lava
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird
                   -> StreetRun.Engine.Obstacle.ObstacleTag'Rock }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag_$csucc ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 case a of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava
                   -> StreetRun.Engine.Obstacle.ObstacleTag'Rock
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock
                   -> StreetRun.Engine.Obstacle.ObstacleTag'Bird
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird
                   -> StreetRun.Engine.Obstacle.$fEnumObstacleTag5 }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag_$ctoEnum ::
    GHC.Types.Int -> StreetRun.Engine.Obstacle.ObstacleTag
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 StreetRun.Engine.Obstacle.$w$ctoEnum ww1 }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag_go ::
    GHC.Prim.Int# -> [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Arity: 1, Strictness: <L,U>m2 -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag_go1 ::
    GHC.Prim.Int# -> [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Arity: 1, Strictness: <L,U>m2 -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag_go2 ::
    GHC.Prim.Int# -> [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Arity: 1, Strictness: <L,U>m2 -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEnumObstacleTag_go3 ::
    GHC.Prim.Int# -> [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2 -}
f6665f768a185efa1963b032d0785cae
  $fEqObstacleInfo ::
    GHC.Classes.Eq StreetRun.Engine.Obstacle.ObstacleInfo
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ StreetRun.Engine.Obstacle.ObstacleInfo
                  StreetRun.Engine.Obstacle.$fEqObstacleInfo_$c==
                  StreetRun.Engine.Obstacle.$fEqObstacleInfo_$c/= -}
f6665f768a185efa1963b032d0785cae
  $fEqObstacleInfo_$c/= ::
    StreetRun.Engine.Obstacle.ObstacleInfo
    -> StreetRun.Engine.Obstacle.ObstacleInfo -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: StreetRun.Engine.Obstacle.ObstacleInfo)
                   (y :: StreetRun.Engine.Obstacle.ObstacleInfo) ->
                 case StreetRun.Engine.Obstacle.$fEqObstacleInfo_$c== x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
f6665f768a185efa1963b032d0785cae
  $fEqObstacleInfo_$c== ::
    StreetRun.Engine.Obstacle.ObstacleInfo
    -> StreetRun.Engine.Obstacle.ObstacleInfo -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: StreetRun.Engine.Obstacle.ObstacleInfo)
                   (ds1 :: StreetRun.Engine.Obstacle.ObstacleInfo) ->
                 case ds of wild {
                   StreetRun.Engine.Obstacle.ObstacleInfo'Lava a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        StreetRun.Engine.Obstacle.ObstacleInfo'Lava b1
                        -> case a1 of ww3 { Animate.Position ww4 ww5 ww6 ww7 ->
                           case b1 of ww8 { Animate.Position ww9 ww10 ww11 ww12 ->
                           case ww4 of wild2 { StreetRun.Engine.Lava.LavaKey'Idle ->
                           case ww9 of wild3 { StreetRun.Engine.Lava.LavaKey'Idle ->
                           case ww5 of wild4 { GHC.Types.I# x ->
                           case ww10 of wild5 { GHC.Types.I# y ->
                           case GHC.Prim.==# x y of lwild {
                             DEFAULT -> GHC.Types.False
                             1#
                             -> case ww6
                                       `cast`
                                     (StreetRun.Engine.Types.N:Seconds[0]) of wild6 { GHC.Types.F# x1 ->
                                case ww11
                                       `cast`
                                     (StreetRun.Engine.Types.N:Seconds[0]) of wild7 { GHC.Types.F# y1 ->
                                case GHC.Prim.eqFloat# x1 y1 of lwild1 {
                                  DEFAULT -> GHC.Types.False
                                  1# -> Animate.$fEqLoop_$c== ww7 ww12 } } } } } } } } } } }
                   StreetRun.Engine.Obstacle.ObstacleInfo'Rock a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        StreetRun.Engine.Obstacle.ObstacleInfo'Rock b1
                        -> case a1 of ww3 { Animate.Position ww4 ww5 ww6 ww7 ->
                           case b1 of ww8 { Animate.Position ww9 ww10 ww11 ww12 ->
                           case ww4 of wild2 { StreetRun.Engine.Rock.RockKey'Idle ->
                           case ww9 of wild3 { StreetRun.Engine.Rock.RockKey'Idle ->
                           case ww5 of wild4 { GHC.Types.I# x ->
                           case ww10 of wild5 { GHC.Types.I# y ->
                           case GHC.Prim.==# x y of lwild {
                             DEFAULT -> GHC.Types.False
                             1#
                             -> case ww6
                                       `cast`
                                     (StreetRun.Engine.Types.N:Seconds[0]) of wild6 { GHC.Types.F# x1 ->
                                case ww11
                                       `cast`
                                     (StreetRun.Engine.Types.N:Seconds[0]) of wild7 { GHC.Types.F# y1 ->
                                case GHC.Prim.eqFloat# x1 y1 of lwild1 {
                                  DEFAULT -> GHC.Types.False
                                  1# -> Animate.$fEqLoop_$c== ww7 ww12 } } } } } } } } } } }
                   StreetRun.Engine.Obstacle.ObstacleInfo'Bird a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        StreetRun.Engine.Obstacle.ObstacleInfo'Bird b1
                        -> case a1 of ww3 { Animate.Position ww4 ww5 ww6 ww7 ->
                           case b1 of ww8 { Animate.Position ww9 ww10 ww11 ww12 ->
                           case ww4 of wild2 { StreetRun.Engine.Bird.BirdKey'Idle ->
                           case ww9 of wild3 { StreetRun.Engine.Bird.BirdKey'Idle ->
                           case ww5 of wild4 { GHC.Types.I# x ->
                           case ww10 of wild5 { GHC.Types.I# y ->
                           case GHC.Prim.==# x y of lwild {
                             DEFAULT -> GHC.Types.False
                             1#
                             -> case ww6
                                       `cast`
                                     (StreetRun.Engine.Types.N:Seconds[0]) of wild6 { GHC.Types.F# x1 ->
                                case ww11
                                       `cast`
                                     (StreetRun.Engine.Types.N:Seconds[0]) of wild7 { GHC.Types.F# y1 ->
                                case GHC.Prim.eqFloat# x1 y1 of lwild1 {
                                  DEFAULT -> GHC.Types.False
                                  1# -> Animate.$fEqLoop_$c== ww7 ww12 } } } } } } } } } } } }) -}
0555b6400d2d8ceda49d732d4b2684e8
  $fEqObstacleState ::
    GHC.Classes.Eq StreetRun.Engine.Obstacle.ObstacleState
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ StreetRun.Engine.Obstacle.ObstacleState
                  StreetRun.Engine.Obstacle.$fEqObstacleState_$c==
                  StreetRun.Engine.Obstacle.$fEqObstacleState_$c/= -}
0555b6400d2d8ceda49d732d4b2684e8
  $fEqObstacleState_$c/= ::
    StreetRun.Engine.Obstacle.ObstacleState
    -> StreetRun.Engine.Obstacle.ObstacleState -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(U))><S(SL),1*U(1*U,1*U(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: StreetRun.Engine.Obstacle.ObstacleState)
                   (y :: StreetRun.Engine.Obstacle.ObstacleState) ->
                 case x of wild { StreetRun.Engine.Obstacle.ObstacleState a1 a2 ->
                 case y of wild1 { StreetRun.Engine.Obstacle.ObstacleState b1 b2 ->
                 case StreetRun.Engine.Obstacle.$fEqObstacleInfo_$c==
                        a1
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.eqFloat
                             a2 `cast` (StreetRun.Engine.Types.N:Distance[0])
                             b2 `cast` (StreetRun.Engine.Types.N:Distance[0]) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
0555b6400d2d8ceda49d732d4b2684e8
  $fEqObstacleState_$c== ::
    StreetRun.Engine.Obstacle.ObstacleState
    -> StreetRun.Engine.Obstacle.ObstacleState -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(U))><S(SL),1*U(1*U,1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: StreetRun.Engine.Obstacle.ObstacleState)
                   (w1 :: StreetRun.Engine.Obstacle.ObstacleState) ->
                 case w of ww { StreetRun.Engine.Obstacle.ObstacleState ww1 ww2 ->
                 case w1 of ww3 { StreetRun.Engine.Obstacle.ObstacleState ww4 ww5 ->
                 StreetRun.Engine.Obstacle.$w$c== ww1 ww2 ww4 ww5 } }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEqObstacleTag ::
    GHC.Classes.Eq StreetRun.Engine.Obstacle.ObstacleTag
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ StreetRun.Engine.Obstacle.ObstacleTag
                  StreetRun.Engine.Obstacle.$fEqObstacleTag_$c==
                  StreetRun.Engine.Obstacle.$fEqObstacleTag_$c/= -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEqObstacleTag_$c/= ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (y :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 case x of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        StreetRun.Engine.Obstacle.ObstacleTag'Lava -> GHC.Types.False }
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        StreetRun.Engine.Obstacle.ObstacleTag'Rock -> GHC.Types.False }
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        StreetRun.Engine.Obstacle.ObstacleTag'Bird
                        -> GHC.Types.False } }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fEqObstacleTag_$c== ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (ds1 :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 case ds of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        StreetRun.Engine.Obstacle.ObstacleTag'Lava -> GHC.Types.True }
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        StreetRun.Engine.Obstacle.ObstacleTag'Rock -> GHC.Types.True }
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        StreetRun.Engine.Obstacle.ObstacleTag'Bird
                        -> GHC.Types.True } }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fOrdObstacleTag ::
    GHC.Classes.Ord StreetRun.Engine.Obstacle.ObstacleTag
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ StreetRun.Engine.Obstacle.ObstacleTag
                  StreetRun.Engine.Obstacle.$fEqObstacleTag
                  StreetRun.Engine.Obstacle.$fOrdObstacleTag_$ccompare
                  StreetRun.Engine.Obstacle.$fOrdObstacleTag_$c<
                  StreetRun.Engine.Obstacle.$fOrdObstacleTag_$c<=
                  StreetRun.Engine.Obstacle.$fOrdObstacleTag_$c>
                  StreetRun.Engine.Obstacle.$fOrdObstacleTag_$c>=
                  StreetRun.Engine.Obstacle.$fOrdObstacleTag_$cmax
                  StreetRun.Engine.Obstacle.$fOrdObstacleTag_$cmin -}
9f0794044af3e60bc0f6840b3f4430f5
  $fOrdObstacleTag_$c< ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (b :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 case a of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava
                   -> case b of wild1 {
                        StreetRun.Engine.Obstacle.ObstacleTag'Lava -> GHC.Types.False
                        StreetRun.Engine.Obstacle.ObstacleTag'Rock -> GHC.Types.True
                        StreetRun.Engine.Obstacle.ObstacleTag'Bird -> GHC.Types.True }
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        StreetRun.Engine.Obstacle.ObstacleTag'Bird -> GHC.Types.True }
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fOrdObstacleTag_$c<= ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (b :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     case a of wild {
                       StreetRun.Engine.Obstacle.ObstacleTag'Lava
                       -> case GHC.Prim.<# a# 0# of lwild {
                            DEFAULT -> GHC.Types.True 1# -> GHC.Types.False }
                       StreetRun.Engine.Obstacle.ObstacleTag'Rock
                       -> case GHC.Prim.<# a# 1# of lwild {
                            DEFAULT -> GHC.Types.True 1# -> GHC.Types.False }
                       StreetRun.Engine.Obstacle.ObstacleTag'Bird
                       -> case GHC.Prim.<# a# 2# of lwild {
                            DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } }
                 } in
                 case b of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava -> $j 0#
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock -> $j 1#
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird -> $j 2# }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fOrdObstacleTag_$c> ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ (a :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (b :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 StreetRun.Engine.Obstacle.$fOrdObstacleTag_$c< b a) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fOrdObstacleTag_$c>= ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (b :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     case b of wild {
                       StreetRun.Engine.Obstacle.ObstacleTag'Lava
                       -> case GHC.Prim.<# a# 0# of lwild {
                            DEFAULT -> GHC.Types.True 1# -> GHC.Types.False }
                       StreetRun.Engine.Obstacle.ObstacleTag'Rock
                       -> case GHC.Prim.<# a# 1# of lwild {
                            DEFAULT -> GHC.Types.True 1# -> GHC.Types.False }
                       StreetRun.Engine.Obstacle.ObstacleTag'Bird
                       -> case GHC.Prim.<# a# 2# of lwild {
                            DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } }
                 } in
                 case a of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava -> $j 0#
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock -> $j 1#
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird -> $j 2# }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fOrdObstacleTag_$ccompare ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (b :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 case a of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava
                   -> case b of wild1 {
                        StreetRun.Engine.Obstacle.ObstacleTag'Lava -> GHC.Types.EQ
                        StreetRun.Engine.Obstacle.ObstacleTag'Rock -> GHC.Types.LT
                        StreetRun.Engine.Obstacle.ObstacleTag'Bird -> GHC.Types.LT }
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock
                   -> case b of wild1 {
                        StreetRun.Engine.Obstacle.ObstacleTag'Lava -> GHC.Types.GT
                        StreetRun.Engine.Obstacle.ObstacleTag'Rock -> GHC.Types.EQ
                        StreetRun.Engine.Obstacle.ObstacleTag'Bird -> GHC.Types.LT }
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        StreetRun.Engine.Obstacle.ObstacleTag'Bird -> GHC.Types.EQ } }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fOrdObstacleTag_$cmax ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (y :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 case StreetRun.Engine.Obstacle.$fOrdObstacleTag_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fOrdObstacleTag_$cmin ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (y :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 case StreetRun.Engine.Obstacle.$fOrdObstacleTag_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fRandomObstacleTag ::
    System.Random.Random StreetRun.Engine.Obstacle.ObstacleTag
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ StreetRun.Engine.Obstacle.ObstacleTag
                  StreetRun.Engine.Obstacle.$fRandomObstacleTag_$crandomR
                  StreetRun.Engine.Obstacle.$fRandomObstacleTag_$crandom
                  StreetRun.Engine.Obstacle.$fRandomObstacleTag_$crandomRs
                  StreetRun.Engine.Obstacle.$fRandomObstacleTag_$crandoms
                  StreetRun.Engine.Obstacle.$fRandomObstacleTag6
                    `cast`
                  (<(StreetRun.Engine.Obstacle.ObstacleTag,
                     StreetRun.Engine.Obstacle.ObstacleTag)>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <StreetRun.Engine.Obstacle.ObstacleTag>_R))
                  StreetRun.Engine.Obstacle.$fRandomObstacleTag1
                    `cast`
                  (Sym (GHC.Types.N:IO[0]
                            <StreetRun.Engine.Obstacle.ObstacleTag>_R)) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fRandomObstacleTag1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          StreetRun.Engine.Obstacle.ObstacleTag #)
  {- Arity: 1, Strictness: <S,U>m,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Random.theStdGen
                        `cast`
                      (GHC.IORef.N:IORef[0] <System.Random.StdGen>_N) of wild { GHC.STRef.STRef r# ->
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ System.Random.StdGen
                        @ (System.Random.StdGen, StreetRun.Engine.Obstacle.ObstacleTag)
                        @ StreetRun.Engine.Obstacle.ObstacleTag
                        r#
                        StreetRun.Engine.Obstacle.$fRandomObstacleTag2
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { DEFAULT -> ds1 } } }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fRandomObstacleTag2 ::
    System.Random.StdGen
    -> (System.Random.StdGen, StreetRun.Engine.Obstacle.ObstacleTag)
  {- Arity: 1, Strictness: <L,U>m,
     Unfolding: (\ (a1 :: System.Random.StdGen) ->
                 case System.Random.$wrandomIvalInteger
                        @ System.Random.StdGen
                        @ GHC.Types.Int
                        System.Random.$fRandomGenStdGen
                        GHC.Num.$fNumInt
                        StreetRun.Engine.Obstacle.$fRandomObstacleTag5
                        StreetRun.Engine.Obstacle.$fRandomObstacleTag4
                        a1 of ww2 { (#,#) ww3 ww4 ->
                 case ww4 of a'1 { System.Random.StdGen ipv ipv1 ->
                 (a'1,
                  case ww3 of wild1 { GHC.Types.I# x ->
                  case GHC.Classes.modInt# x 3# of ww1 { DEFAULT ->
                  GHC.List.$w!!
                    @ StreetRun.Engine.Obstacle.ObstacleTag
                    StreetRun.Engine.Obstacle.$fRandomObstacleTag3
                    ww1 } }) } }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fRandomObstacleTag3 :: [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Unfolding: (case StreetRun.Engine.Obstacle.$wgo
                        0# of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ StreetRun.Engine.Obstacle.ObstacleTag ww1 ww2 }) -}
c52302c24a2a4ca39c16fd36e4f7ad8d
  $fRandomObstacleTag4 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
d67920f4443402024e617729808b09fc
  $fRandomObstacleTag5 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fRandomObstacleTag6 ::
    (StreetRun.Engine.Obstacle.ObstacleTag,
     StreetRun.Engine.Obstacle.ObstacleTag)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          StreetRun.Engine.Obstacle.ObstacleTag #)
  {- Arity: 2, Strictness: <L,U(U,U)><S,U>m,
     Unfolding: (\ (range :: (StreetRun.Engine.Obstacle.ObstacleTag,
                              StreetRun.Engine.Obstacle.ObstacleTag))
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Random.theStdGen
                        `cast`
                      (GHC.IORef.N:IORef[0] <System.Random.StdGen>_N) of wild { GHC.STRef.STRef r# ->
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ System.Random.StdGen
                        @ (System.Random.StdGen, StreetRun.Engine.Obstacle.ObstacleTag)
                        @ StreetRun.Engine.Obstacle.ObstacleTag
                        r#
                        (\ (a1 :: System.Random.StdGen) ->
                         case range of ww { (,) ww1 ww2 ->
                         case StreetRun.Engine.Obstacle.$w$s$crandomR
                                ww1
                                ww2
                                a1 of ww3 { (#,#) ww4 ww5 ->
                         case ww5 of a'1 { System.Random.StdGen ipv ipv1 ->
                         (a'1, ww4) } } })
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { DEFAULT -> ds1 } } }) -}
2b0ebd71ebd4366f511e13f282b5b005
  $fRandomObstacleTag7 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fRandomObstacleTag8 ::
    (StreetRun.Engine.Obstacle.ObstacleTag,
     StreetRun.Engine.Obstacle.ObstacleTag)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((StreetRun.Engine.Obstacle.ObstacleTag'Lava,
                  StreetRun.Engine.Obstacle.ObstacleTag'Bird)) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fRandomObstacleTag_$crandom ::
    System.Random.RandomGen g =>
    g -> (StreetRun.Engine.Obstacle.ObstacleTag, g)
  {- Arity: 2,
     Strictness: <L,U(C(U(1*U(U),U)),C(U(U(U),1*U(U))),A)><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ g ($dRandomGen :: System.Random.RandomGen g) (g1 :: g) ->
                 StreetRun.Engine.Obstacle.$fRandomObstacleTag_$crandomR
                   @ g
                   $dRandomGen
                   StreetRun.Engine.Obstacle.$fRandomObstacleTag8
                   g1) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fRandomObstacleTag_$crandomR ::
    System.Random.RandomGen g =>
    (StreetRun.Engine.Obstacle.ObstacleTag,
     StreetRun.Engine.Obstacle.ObstacleTag)
    -> g -> (StreetRun.Engine.Obstacle.ObstacleTag, g)
  {- Arity: 3,
     Strictness: <L,U(C(U(1*U(U),U)),C(U(U(U),1*U(U))),A)><S,1*U(1*U,1*U)><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ g
                   (w :: System.Random.RandomGen g)
                   (w1 :: (StreetRun.Engine.Obstacle.ObstacleTag,
                           StreetRun.Engine.Obstacle.ObstacleTag))
                   (w2 :: g) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case StreetRun.Engine.Obstacle.$w$crandomR
                        @ g
                        w
                        ww1
                        ww2
                        w2 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5) } }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fRandomObstacleTag_$crandomRs ::
    System.Random.RandomGen g =>
    (StreetRun.Engine.Obstacle.ObstacleTag,
     StreetRun.Engine.Obstacle.ObstacleTag)
    -> g -> [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Arity: 3,
     Strictness: <L,U(C(U(1*U(U),U)),C(U(U(U),1*U(U))),A)><S,U(U,U)><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ g
                   ($dRandomGen :: System.Random.RandomGen g)
                   (ival :: (StreetRun.Engine.Obstacle.ObstacleTag,
                             StreetRun.Engine.Obstacle.ObstacleTag))
                   (g1 :: g) ->
                 GHC.Base.build
                   @ StreetRun.Engine.Obstacle.ObstacleTag
                   (\ @ b1
                      (cons :: StreetRun.Engine.Obstacle.ObstacleTag
                               -> b1 -> b1)[OneShot]
                      (_nil :: b1)[OneShot] ->
                    letrec {
                      go :: g -> b1 {- Arity: 1 -}
                      = \ (g2 :: g) ->
                        case StreetRun.Engine.Obstacle.$fRandomObstacleTag_$crandomR
                               @ g
                               $dRandomGen
                               ival
                               g2 of wild { (,) x g' ->
                        case x of x1 { DEFAULT -> cons x1 (go g') } }
                    } in
                    go g1)) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fRandomObstacleTag_$crandoms ::
    System.Random.RandomGen g =>
    g -> [StreetRun.Engine.Obstacle.ObstacleTag]
  {- Arity: 2,
     Strictness: <L,U(C(U(1*U(U),U)),C(U(U(U),1*U(U))),A)><L,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ g ($dRandomGen :: System.Random.RandomGen g) (g1 :: g) ->
                 GHC.Base.build
                   @ StreetRun.Engine.Obstacle.ObstacleTag
                   (\ @ b1
                      (cons :: StreetRun.Engine.Obstacle.ObstacleTag
                               -> b1 -> b1)[OneShot]
                      (_nil :: b1)[OneShot] ->
                    letrec {
                      go :: g -> b1 {- Arity: 1 -}
                      = \ (g2 :: g) ->
                        case StreetRun.Engine.Obstacle.$fRandomObstacleTag_$crandomR
                               @ g
                               $dRandomGen
                               StreetRun.Engine.Obstacle.$fRandomObstacleTag8
                               g2 of wild { (,) x g' ->
                        case x of x1 { DEFAULT -> cons x1 (go g') } }
                    } in
                    go g1)) -}
f6665f768a185efa1963b032d0785cae
  $fShowObstacleInfo ::
    GHC.Show.Show StreetRun.Engine.Obstacle.ObstacleInfo
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ StreetRun.Engine.Obstacle.ObstacleInfo
                  StreetRun.Engine.Obstacle.$fShowObstacleInfo_$cshowsPrec
                  StreetRun.Engine.Obstacle.$fShowObstacleInfo_$cshow
                  StreetRun.Engine.Obstacle.$fShowObstacleInfo_$cshowList -}
f6665f768a185efa1963b032d0785cae
  $fShowObstacleInfo1 ::
    StreetRun.Engine.Obstacle.ObstacleInfo -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (w :: StreetRun.Engine.Obstacle.ObstacleInfo) ->
                 StreetRun.Engine.Obstacle.$w$cshowsPrec 0# w) -}
f87492144e2ee508b4bd51194547a0a0
  $fShowObstacleInfo2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   StreetRun.Engine.Obstacle.$fShowObstacleInfo3) -}
bc953c14d5a06e7a719e52744ee2332b
  $fShowObstacleInfo3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ObstacleInfo'Bird "#) -}
f15f5ecd14033536213eed24b7679b07
  $fShowObstacleInfo4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   StreetRun.Engine.Obstacle.$fShowObstacleInfo5) -}
febe1de17a028c48da941bb4e402a5be
  $fShowObstacleInfo5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ObstacleInfo'Rock "#) -}
1310ec77e2ab28a55b41d03ddd872810
  $fShowObstacleInfo6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   StreetRun.Engine.Obstacle.$fShowObstacleInfo7) -}
502b789030bb15ff7a4982d5490aa778
  $fShowObstacleInfo7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ObstacleInfo'Lava "#) -}
3866b02c7c5261d2538e9b76e5dfccd4
  $fShowObstacleInfo8 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
f6665f768a185efa1963b032d0785cae
  $fShowObstacleInfo_$cshow ::
    StreetRun.Engine.Obstacle.ObstacleInfo -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: StreetRun.Engine.Obstacle.ObstacleInfo) ->
                 StreetRun.Engine.Obstacle.$fShowObstacleInfo_$cshowsPrec
                   StreetRun.Engine.Obstacle.$fShowObstacleInfo8
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f6665f768a185efa1963b032d0785cae
  $fShowObstacleInfo_$cshowList ::
    [StreetRun.Engine.Obstacle.ObstacleInfo] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [StreetRun.Engine.Obstacle.ObstacleInfo])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ StreetRun.Engine.Obstacle.ObstacleInfo
                   StreetRun.Engine.Obstacle.$fShowObstacleInfo1
                   ls
                   s) -}
f6665f768a185efa1963b032d0785cae
  $fShowObstacleInfo_$cshowsPrec ::
    GHC.Types.Int
    -> StreetRun.Engine.Obstacle.ObstacleInfo -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: StreetRun.Engine.Obstacle.ObstacleInfo) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 StreetRun.Engine.Obstacle.$w$cshowsPrec ww1 w1 }) -}
0555b6400d2d8ceda49d732d4b2684e8
  $fShowObstacleState ::
    GHC.Show.Show StreetRun.Engine.Obstacle.ObstacleState
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ StreetRun.Engine.Obstacle.ObstacleState
                  StreetRun.Engine.Obstacle.$fShowObstacleState_$cshowsPrec
                  StreetRun.Engine.Obstacle.$fShowObstacleState_$cshow
                  StreetRun.Engine.Obstacle.$fShowObstacleState_$cshowList -}
0555b6400d2d8ceda49d732d4b2684e8
  $fShowObstacleState1 ::
    StreetRun.Engine.Obstacle.ObstacleState -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U(U))>,
     Unfolding: (\ (w :: StreetRun.Engine.Obstacle.ObstacleState) ->
                 case w of ww { StreetRun.Engine.Obstacle.ObstacleState ww1 ww2 ->
                 StreetRun.Engine.Obstacle.$w$cshowsPrec1 0# ww1 ww2 }) -}
c6868d6ac2e7fc504c734c2e90a34e64
  $fShowObstacleState2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("}"#) -}
134449f0cf1c21c4e5377ca8a13ba705
  $fShowObstacleState3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("osDistance = "#) -}
9830c32ac0f9aa950da039bc1a740d16
  $fShowObstacleState4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("osInfo = "#) -}
fb0179c61a6d96d15a9535c3db5178cb
  $fShowObstacleState5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ObstacleState {"#) -}
45db3e2f075f7b3b4d6b32f1ac1b25b7
  $fShowObstacleState6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   StreetRun.Engine.Obstacle.$fShowObstacleState2) -}
0555b6400d2d8ceda49d732d4b2684e8
  $fShowObstacleState_$cshow ::
    StreetRun.Engine.Obstacle.ObstacleState -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U(U))>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: StreetRun.Engine.Obstacle.ObstacleState) ->
                 case w of ww { StreetRun.Engine.Obstacle.ObstacleState ww1 ww2 ->
                 StreetRun.Engine.Obstacle.$w$cshow ww1 ww2 }) -}
0555b6400d2d8ceda49d732d4b2684e8
  $fShowObstacleState_$cshowList ::
    [StreetRun.Engine.Obstacle.ObstacleState] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [StreetRun.Engine.Obstacle.ObstacleState])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ StreetRun.Engine.Obstacle.ObstacleState
                   StreetRun.Engine.Obstacle.$fShowObstacleState1
                   ls
                   s) -}
0555b6400d2d8ceda49d732d4b2684e8
  $fShowObstacleState_$cshowsPrec ::
    GHC.Types.Int
    -> StreetRun.Engine.Obstacle.ObstacleState -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: StreetRun.Engine.Obstacle.ObstacleState) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { StreetRun.Engine.Obstacle.ObstacleState ww3 ww4 ->
                 StreetRun.Engine.Obstacle.$w$cshowsPrec1 ww1 ww3 ww4 } }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fShowObstacleTag ::
    GHC.Show.Show StreetRun.Engine.Obstacle.ObstacleTag
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ StreetRun.Engine.Obstacle.ObstacleTag
                  StreetRun.Engine.Obstacle.$fShowObstacleTag_$cshowsPrec
                  StreetRun.Engine.Obstacle.$fShowObstacleTag_$cshow
                  StreetRun.Engine.Obstacle.$fShowObstacleTag_$cshowList -}
6e3527980a6ec1a5d3b4a73c36a3894b
  $fShowObstacleTag1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   StreetRun.Engine.Obstacle.$fShowObstacleTag2) -}
3847b047d65136e8a4a1f20c942a4791
  $fShowObstacleTag2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ObstacleTag'Bird"#) -}
bd107ec8423e86fae4948f26e4562d8f
  $fShowObstacleTag3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   StreetRun.Engine.Obstacle.$fShowObstacleTag4) -}
5852527c2ba1c4ef397ff3af7cf2fd80
  $fShowObstacleTag4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ObstacleTag'Rock"#) -}
e64aa08e4e42db07b83fa3eae2986cea
  $fShowObstacleTag5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   StreetRun.Engine.Obstacle.$fShowObstacleTag6) -}
977b20cb17c863d5edcb3990571ae9ce
  $fShowObstacleTag6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ObstacleTag'Lava"#) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fShowObstacleTag_$cshow ::
    StreetRun.Engine.Obstacle.ObstacleTag -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: StreetRun.Engine.Obstacle.ObstacleTag) ->
                 case x of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava
                   -> StreetRun.Engine.Obstacle.$fShowObstacleTag5
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock
                   -> StreetRun.Engine.Obstacle.$fShowObstacleTag3
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird
                   -> StreetRun.Engine.Obstacle.$fShowObstacleTag1 }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fShowObstacleTag_$cshowList ::
    [StreetRun.Engine.Obstacle.ObstacleTag] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [StreetRun.Engine.Obstacle.ObstacleTag])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ StreetRun.Engine.Obstacle.ObstacleTag
                   StreetRun.Engine.Obstacle.$w$cshowsPrec2
                   ls
                   s) -}
9f0794044af3e60bc0f6840b3f4430f5
  $fShowObstacleTag_$cshowsPrec ::
    GHC.Types.Int
    -> StreetRun.Engine.Obstacle.ObstacleTag -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (w2 :: GHC.Base.String) ->
                 StreetRun.Engine.Obstacle.$w$cshowsPrec2 w1 w2) -}
0555b6400d2d8ceda49d732d4b2684e8
  $sel:osDistance:ObstacleState ::
    StreetRun.Engine.Obstacle.ObstacleState
    -> StreetRun.Engine.Types.Distance
  RecSel Left StreetRun.Engine.Obstacle.ObstacleState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: StreetRun.Engine.Obstacle.ObstacleState) ->
                 case ds of wild { StreetRun.Engine.Obstacle.ObstacleState ds1 ds2 ->
                 ds2 }) -}
0555b6400d2d8ceda49d732d4b2684e8
  $sel:osInfo:ObstacleState ::
    StreetRun.Engine.Obstacle.ObstacleState
    -> StreetRun.Engine.Obstacle.ObstacleInfo
  RecSel Left StreetRun.Engine.Obstacle.ObstacleState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: StreetRun.Engine.Obstacle.ObstacleState) ->
                 case ds of wild { StreetRun.Engine.Obstacle.ObstacleState ds1 ds2 ->
                 ds1 }) -}
925da8f0fc0e6431235d321833fde271
  $tc'ObstacleInfo'Bird :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18372350051218171373##
                   3760136764626601906##
                   StreetRun.Engine.Obstacle.$trModule
                   StreetRun.Engine.Obstacle.$tc'ObstacleInfo'Bird2
                   0#
                   StreetRun.Engine.Obstacle.$tc'ObstacleInfo'Bird1) -}
6f1a741a51f8c15173a8c0e5a16b0799
  $tc'ObstacleInfo'Bird1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
517c31e3dc6ba9637072905b5530c1e0
  $tc'ObstacleInfo'Bird2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   StreetRun.Engine.Obstacle.$tc'ObstacleInfo'Bird3) -}
743a601c96878c6de151517ea151b41b
  $tc'ObstacleInfo'Bird3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ObstacleInfo'Bird"#) -}
807936d70fa5fe4c0e2943307c7f278b
  $tc'ObstacleInfo'Lava :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7260840515288799353##
                   12493139155546687335##
                   StreetRun.Engine.Obstacle.$trModule
                   StreetRun.Engine.Obstacle.$tc'ObstacleInfo'Lava2
                   0#
                   StreetRun.Engine.Obstacle.$tc'ObstacleInfo'Lava1) -}
4a9fe76591263442711f7dfd8416a89e
  $tc'ObstacleInfo'Lava1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7d3d8081f0ca651c4b33f06993e49929
  $tc'ObstacleInfo'Lava2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   StreetRun.Engine.Obstacle.$tc'ObstacleInfo'Lava3) -}
9680ed0fa4a27c7c2f96352c971816a0
  $tc'ObstacleInfo'Lava3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ObstacleInfo'Lava"#) -}
d67124dbf3c3d2ca088c4d8939f2b3bd
  $tc'ObstacleInfo'Rock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   165443154536456235##
                   17230978242292740535##
                   StreetRun.Engine.Obstacle.$trModule
                   StreetRun.Engine.Obstacle.$tc'ObstacleInfo'Rock2
                   0#
                   StreetRun.Engine.Obstacle.$tc'ObstacleInfo'Rock1) -}
ddc1423efdfca1b94384e31e71cac366
  $tc'ObstacleInfo'Rock1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
bedd5d17d3487c5cf0785acd81ea10c8
  $tc'ObstacleInfo'Rock2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   StreetRun.Engine.Obstacle.$tc'ObstacleInfo'Rock3) -}
da77bef0cb40cdae2ef268ceedf26089
  $tc'ObstacleInfo'Rock3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ObstacleInfo'Rock"#) -}
f62086a4a75b5d0d670a519179a4153c
  $tc'ObstacleState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13936579208860333107##
                   9573577779114113832##
                   StreetRun.Engine.Obstacle.$trModule
                   StreetRun.Engine.Obstacle.$tc'ObstacleState2
                   0#
                   StreetRun.Engine.Obstacle.$tc'ObstacleState1) -}
2e7c572f378c274252892a82dc8c3f76
  $tc'ObstacleState1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0ebe24f9ec20cb9ba68a8e268248efa0
  $tc'ObstacleState2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   StreetRun.Engine.Obstacle.$tc'ObstacleState3) -}
3f87ba2af42957c9057d5f2bcf0a31e2
  $tc'ObstacleState3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ObstacleState"#) -}
de82566dcb21e47b0d0645c1dcdbf1ff
  $tc'ObstacleTag'Bird :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5267518594129009004##
                   8758596330433171371##
                   StreetRun.Engine.Obstacle.$trModule
                   StreetRun.Engine.Obstacle.$tc'ObstacleTag'Bird2
                   0#
                   StreetRun.Engine.Obstacle.$tc'ObstacleTag'Bird1) -}
77da5f06ba7db5081c8f52bb533fa55c
  $tc'ObstacleTag'Bird1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
e4aafaf9872766d3d0cddeca94f3b205
  $tc'ObstacleTag'Bird2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   StreetRun.Engine.Obstacle.$tc'ObstacleTag'Bird3) -}
8a1c495b3d57142a50f4c64736bc6241
  $tc'ObstacleTag'Bird3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ObstacleTag'Bird"#) -}
39dad1258ea06911d83e6903075f4fb3
  $tc'ObstacleTag'Lava :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4799009191406954579##
                   17717240777301215206##
                   StreetRun.Engine.Obstacle.$trModule
                   StreetRun.Engine.Obstacle.$tc'ObstacleTag'Lava1
                   0#
                   StreetRun.Engine.Obstacle.$tc'ObstacleTag'Bird1) -}
cb05b64c90129d4dbf96779de2aca942
  $tc'ObstacleTag'Lava1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   StreetRun.Engine.Obstacle.$tc'ObstacleTag'Lava2) -}
66bd3292683a633bdab55395d660f9fd
  $tc'ObstacleTag'Lava2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ObstacleTag'Lava"#) -}
24013a84c108fc09890e48a8db560d06
  $tc'ObstacleTag'Rock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16012797175539533271##
                   13043999672702315704##
                   StreetRun.Engine.Obstacle.$trModule
                   StreetRun.Engine.Obstacle.$tc'ObstacleTag'Rock1
                   0#
                   StreetRun.Engine.Obstacle.$tc'ObstacleTag'Bird1) -}
2c0bcc6bf8d157ffd4c4abd697f34c7f
  $tc'ObstacleTag'Rock1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   StreetRun.Engine.Obstacle.$tc'ObstacleTag'Rock2) -}
959242e6b8994bff441a0c7c6e39378b
  $tc'ObstacleTag'Rock2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ObstacleTag'Rock"#) -}
35e419f4ada88da65c593f64285f0bce
  $tcObstacleInfo :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16296939423688454049##
                   16786258868340905633##
                   StreetRun.Engine.Obstacle.$trModule
                   StreetRun.Engine.Obstacle.$tcObstacleInfo1
                   0#
                   GHC.Types.krep$*) -}
1f68fa8a42669966ba721e7e8f793b57
  $tcObstacleInfo1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   StreetRun.Engine.Obstacle.$tcObstacleInfo2) -}
71518e70825794a64d1c5d727be5a7ec
  $tcObstacleInfo2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ObstacleInfo"#) -}
49e86082de0bb2a004477a3633a4f16b
  $tcObstacleState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   585758950682368018##
                   5247367617792157655##
                   StreetRun.Engine.Obstacle.$trModule
                   StreetRun.Engine.Obstacle.$tcObstacleState1
                   0#
                   GHC.Types.krep$*) -}
98a8f23e44af6893c381d45e356bc4cf
  $tcObstacleState1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   StreetRun.Engine.Obstacle.$tcObstacleState2) -}
a88331730e14660db04ff93fc9922412
  $tcObstacleState2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ObstacleState"#) -}
1d34f8ffba2d23c9ff1e3b845a300f17
  $tcObstacleTag :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14197338057268572996##
                   6682350771136848298##
                   StreetRun.Engine.Obstacle.$trModule
                   StreetRun.Engine.Obstacle.$tcObstacleTag1
                   0#
                   GHC.Types.krep$*) -}
d9c31a284714f42c1a206ab7bbe27af0
  $tcObstacleTag1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   StreetRun.Engine.Obstacle.$tcObstacleTag2) -}
89846d80c4e339aa879942b8ce834be9
  $tcObstacleTag2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ObstacleTag"#) -}
bed2d773580a5b749455c181821db454
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   StreetRun.Engine.Obstacle.$trModule3
                   StreetRun.Engine.Obstacle.$trModule1) -}
33cf584a0b16ddb2a6c2e03822bbe5d6
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   StreetRun.Engine.Obstacle.$trModule2) -}
a719ca2b92fb742ff961964ac1c44656
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("StreetRun.Engine.Obstacle"#) -}
fa8ed97ac5b7b278f42f43f32f46a6d7
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   StreetRun.Engine.Obstacle.$trModule4) -}
7154f3d8639a596bc2214c7bb30f4e7b
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("street-runner-0.0.0-GEoHgSQZcIaHrT8BK7yHRE"#) -}
bac9ed002786bdf37204ece2a75d7210
  $w$c== ::
    StreetRun.Engine.Obstacle.ObstacleInfo
    -> StreetRun.Engine.Types.Distance
    -> StreetRun.Engine.Obstacle.ObstacleInfo
    -> StreetRun.Engine.Types.Distance
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U)><S,1*U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: StreetRun.Engine.Obstacle.ObstacleInfo)
                   (ww1 :: StreetRun.Engine.Types.Distance)
                   (ww2 :: StreetRun.Engine.Obstacle.ObstacleInfo)
                   (ww3 :: StreetRun.Engine.Types.Distance) ->
                 case StreetRun.Engine.Obstacle.$fEqObstacleInfo_$c==
                        ww
                        ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.eqFloat
                        ww1 `cast` (StreetRun.Engine.Types.N:Distance[0])
                        ww3 `cast` (StreetRun.Engine.Types.N:Distance[0]) }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $w$crandomR ::
    System.Random.RandomGen g =>
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag
    -> g
    -> (# StreetRun.Engine.Obstacle.ObstacleTag, g #)
  {- Arity: 4,
     Strictness: <L,U(C(U(1*U(U),U)),C(U(U(U),1*U(U))),A)><L,1*U><L,1*U><L,U>,
     Inline: [2],
     Unfolding: (\ @ g
                   (w :: System.Random.RandomGen g)
                   (ww :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (ww1 :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (w1 :: g) ->
                 let {
                   ds :: (GHC.Types.Int, g)
                   = let {
                       $j :: GHC.Integer.Type.Integer -> (GHC.Types.Int, g)
                         <join 1> {- Arity: 1, Strictness: <S,U>m -}
                       = \ (karg :: GHC.Integer.Type.Integer)[OneShot] ->
                         case ww of wild {
                           StreetRun.Engine.Obstacle.ObstacleTag'Lava
                           -> case System.Random.$wrandomIvalInteger
                                     @ g
                                     @ GHC.Types.Int
                                     w
                                     GHC.Num.$fNumInt
                                     StreetRun.Engine.Obstacle.$fRandomObstacleTag5
                                     karg
                                     w1 of ww2 { (#,#) ww3 ww4 ->
                              (ww3, ww4) }
                           StreetRun.Engine.Obstacle.ObstacleTag'Rock
                           -> case System.Random.$wrandomIvalInteger
                                     @ g
                                     @ GHC.Types.Int
                                     w
                                     GHC.Num.$fNumInt
                                     StreetRun.Engine.Obstacle.$fRandomObstacleTag7
                                     karg
                                     w1 of ww2 { (#,#) ww3 ww4 ->
                              (ww3, ww4) }
                           StreetRun.Engine.Obstacle.ObstacleTag'Bird
                           -> case System.Random.$wrandomIvalInteger
                                     @ g
                                     @ GHC.Types.Int
                                     w
                                     GHC.Num.$fNumInt
                                     StreetRun.Engine.Obstacle.$fRandomObstacleTag4
                                     karg
                                     w1 of ww2 { (#,#) ww3 ww4 ->
                              (ww3, ww4) } }
                     } in
                     case ww1 of wild {
                       StreetRun.Engine.Obstacle.ObstacleTag'Lava
                       -> $j StreetRun.Engine.Obstacle.$fRandomObstacleTag5
                       StreetRun.Engine.Obstacle.ObstacleTag'Rock
                       -> $j StreetRun.Engine.Obstacle.$fRandomObstacleTag7
                       StreetRun.Engine.Obstacle.ObstacleTag'Bird
                       -> $j StreetRun.Engine.Obstacle.$fRandomObstacleTag4 }
                 } in
                 (# case ds of wild { (,) index g' ->
                    case index of wild1 { GHC.Types.I# x ->
                    case GHC.Classes.modInt# x 3# of ww2 { DEFAULT ->
                    GHC.List.$w!!
                      @ StreetRun.Engine.Obstacle.ObstacleTag
                      StreetRun.Engine.Obstacle.$fRandomObstacleTag3
                      ww2 } } },
                    case ds of wild { (,) index g' -> g' } #)) -}
b0b101ed60bc9554ee9975ff4738c689
  $w$cshow ::
    StreetRun.Engine.Obstacle.ObstacleInfo
    -> StreetRun.Engine.Types.Distance -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: StreetRun.Engine.Obstacle.ObstacleInfo)
                   (ww1 :: StreetRun.Engine.Types.Distance) ->
                 GHC.CString.unpackAppendCString#
                   StreetRun.Engine.Obstacle.$fShowObstacleState5
                   (GHC.CString.unpackAppendCString#
                      StreetRun.Engine.Obstacle.$fShowObstacleState4
                      (StreetRun.Engine.Obstacle.$w$cshowsPrec
                         0#
                         ww
                         (GHC.Base.++
                            @ GHC.Types.Char
                            GHC.Show.showCommaSpace1
                            (GHC.CString.unpackAppendCString#
                               StreetRun.Engine.Obstacle.$fShowObstacleState3
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  StreetRun.Engine.Types.$fShowDistance2
                                  (case ww1
                                          `cast`
                                        (StreetRun.Engine.Types.N:Distance[0]) of ww2 { GHC.Types.F# ww3 ->
                                   GHC.Float.$w$sshowSignedFloat1
                                     GHC.Float.$fShowFloat2
                                     StreetRun.Engine.Types.$fShowDistance4
                                     ww3
                                     StreetRun.Engine.Obstacle.$fShowObstacleState6 }))))))) -}
f6665f768a185efa1963b032d0785cae
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> StreetRun.Engine.Obstacle.ObstacleInfo -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: StreetRun.Engine.Obstacle.ObstacleInfo) ->
                 case w of wild {
                   StreetRun.Engine.Obstacle.ObstacleInfo'Lava b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = case b1 of ww2 { Animate.Position ww3 ww4 ww5 ww6 ->
                          Animate.$w$cshowsPrec2
                            @ StreetRun.Engine.Lava.LavaKey
                            @ StreetRun.Engine.Types.Seconds
                            StreetRun.Engine.Lava.$fShowLavaKey
                            StreetRun.Engine.Types.$fShowSeconds
                            11#
                            ww3
                            ww4
                            ww5
                            ww6 }
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             StreetRun.Engine.Obstacle.$fShowObstacleInfo6
                             (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                StreetRun.Engine.Obstacle.$fShowObstacleInfo6
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   StreetRun.Engine.Obstacle.ObstacleInfo'Rock b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = case b1 of ww2 { Animate.Position ww3 ww4 ww5 ww6 ->
                          Animate.$w$cshowsPrec2
                            @ StreetRun.Engine.Rock.RockKey
                            @ StreetRun.Engine.Types.Seconds
                            StreetRun.Engine.Rock.$fShowRockKey
                            StreetRun.Engine.Types.$fShowSeconds
                            11#
                            ww3
                            ww4
                            ww5
                            ww6 }
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             StreetRun.Engine.Obstacle.$fShowObstacleInfo4
                             (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                StreetRun.Engine.Obstacle.$fShowObstacleInfo4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   StreetRun.Engine.Obstacle.ObstacleInfo'Bird b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = case b1 of ww2 { Animate.Position ww3 ww4 ww5 ww6 ->
                          Animate.$w$cshowsPrec2
                            @ StreetRun.Engine.Bird.BirdKey
                            @ StreetRun.Engine.Types.Seconds
                            StreetRun.Engine.Bird.$fShowBirdKey
                            StreetRun.Engine.Types.$fShowSeconds
                            11#
                            ww3
                            ww4
                            ww5
                            ww6 }
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             StreetRun.Engine.Obstacle.$fShowObstacleInfo2
                             (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                StreetRun.Engine.Obstacle.$fShowObstacleInfo2
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
b9684398c5bce90828a03af637b51c8d
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> StreetRun.Engine.Obstacle.ObstacleInfo
    -> StreetRun.Engine.Types.Distance
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,U><L,1*U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: StreetRun.Engine.Obstacle.ObstacleInfo)
                   (ww2 :: StreetRun.Engine.Types.Distance) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = StreetRun.Engine.Obstacle.$w$cshowsPrec 0# ww1
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = StreetRun.Engine.Types.$w$cshowsPrec 0# ww2
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        StreetRun.Engine.Obstacle.$fShowObstacleState5
                        (GHC.CString.unpackAppendCString#
                           StreetRun.Engine.Obstacle.$fShowObstacleState4
                           (f (GHC.Base.++
                                 @ GHC.Types.Char
                                 GHC.Show.showCommaSpace1
                                 (GHC.CString.unpackAppendCString#
                                    StreetRun.Engine.Obstacle.$fShowObstacleState3
                                    (f1
                                       (GHC.CString.unpackAppendCString#
                                          StreetRun.Engine.Obstacle.$fShowObstacleState2
                                          x))))))
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           StreetRun.Engine.Obstacle.$fShowObstacleState5
                           (GHC.CString.unpackAppendCString#
                              StreetRun.Engine.Obstacle.$fShowObstacleState4
                              (f (GHC.Base.++
                                    @ GHC.Types.Char
                                    GHC.Show.showCommaSpace1
                                    (GHC.CString.unpackAppendCString#
                                       StreetRun.Engine.Obstacle.$fShowObstacleState3
                                       (f1
                                          (GHC.CString.unpackAppendCString#
                                             StreetRun.Engine.Obstacle.$fShowObstacleState2
                                             (GHC.Types.:
                                                @ GHC.Types.Char
                                                GHC.Show.$fShow(,)2
                                                x)))))))) }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $w$cshowsPrec2 ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (w :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   StreetRun.Engine.Obstacle.ObstacleTag'Lava
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        StreetRun.Engine.Obstacle.$fShowObstacleTag5
                        w1
                   StreetRun.Engine.Obstacle.ObstacleTag'Rock
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        StreetRun.Engine.Obstacle.$fShowObstacleTag3
                        w1
                   StreetRun.Engine.Obstacle.ObstacleTag'Bird
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        StreetRun.Engine.Obstacle.$fShowObstacleTag1
                        w1 }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $w$ctoEnum ::
    GHC.Prim.Int# -> StreetRun.Engine.Obstacle.ObstacleTag
  {- Arity: 1, Strictness: <S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.>=# ww 0# of lwild {
                   DEFAULT -> StreetRun.Engine.Obstacle.$wlvl ww
                   1#
                   -> case GHC.Prim.<=# ww 2# of lwild1 {
                        DEFAULT -> StreetRun.Engine.Obstacle.$wlvl ww
                        1#
                        -> GHC.Prim.tagToEnum#
                             @ StreetRun.Engine.Obstacle.ObstacleTag
                             ww } }) -}
9f0794044af3e60bc0f6840b3f4430f5
  $w$s$crandomR ::
    StreetRun.Engine.Obstacle.ObstacleTag
    -> StreetRun.Engine.Obstacle.ObstacleTag
    -> System.Random.StdGen
    -> (# StreetRun.Engine.Obstacle.ObstacleTag,
          System.Random.StdGen #)
  {- Arity: 3, Strictness: <L,1*U><L,1*U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (ww1 :: StreetRun.Engine.Obstacle.ObstacleTag)
                   (w :: System.Random.StdGen) ->
                 let {
                   ds :: (GHC.Types.Int, System.Random.StdGen)
                   = let {
                       $j :: GHC.Integer.Type.Integer
                             -> (GHC.Types.Int, System.Random.StdGen)
                         <join 1> {- Arity: 1, Strictness: <S,U>m -}
                       = \ (karg :: GHC.Integer.Type.Integer)[OneShot] ->
                         case ww of wild {
                           StreetRun.Engine.Obstacle.ObstacleTag'Lava
                           -> case System.Random.$wrandomIvalInteger
                                     @ System.Random.StdGen
                                     @ GHC.Types.Int
                                     System.Random.$fRandomGenStdGen
                                     GHC.Num.$fNumInt
                                     StreetRun.Engine.Obstacle.$fRandomObstacleTag5
                                     karg
                                     w of ww2 { (#,#) ww3 ww4 ->
                              (ww3, ww4) }
                           StreetRun.Engine.Obstacle.ObstacleTag'Rock
                           -> case System.Random.$wrandomIvalInteger
                                     @ System.Random.StdGen
                                     @ GHC.Types.Int
                                     System.Random.$fRandomGenStdGen
                                     GHC.Num.$fNumInt
                                     StreetRun.Engine.Obstacle.$fRandomObstacleTag7
                                     karg
                                     w of ww2 { (#,#) ww3 ww4 ->
                              (ww3, ww4) }
                           StreetRun.Engine.Obstacle.ObstacleTag'Bird
                           -> case System.Random.$wrandomIvalInteger
                                     @ System.Random.StdGen
                                     @ GHC.Types.Int
                                     System.Random.$fRandomGenStdGen
                                     GHC.Num.$fNumInt
                                     StreetRun.Engine.Obstacle.$fRandomObstacleTag4
                                     karg
                                     w of ww2 { (#,#) ww3 ww4 ->
                              (ww3, ww4) } }
                     } in
                     case ww1 of wild {
                       StreetRun.Engine.Obstacle.ObstacleTag'Lava
                       -> $j StreetRun.Engine.Obstacle.$fRandomObstacleTag5
                       StreetRun.Engine.Obstacle.ObstacleTag'Rock
                       -> $j StreetRun.Engine.Obstacle.$fRandomObstacleTag7
                       StreetRun.Engine.Obstacle.ObstacleTag'Bird
                       -> $j StreetRun.Engine.Obstacle.$fRandomObstacleTag4 }
                 } in
                 (# case ds of wild { (,) index g' ->
                    case index of wild1 { GHC.Types.I# x ->
                    case GHC.Classes.modInt# x 3# of ww2 { DEFAULT ->
                    GHC.List.$w!!
                      @ StreetRun.Engine.Obstacle.ObstacleTag
                      StreetRun.Engine.Obstacle.$fRandomObstacleTag3
                      ww2 } } },
                    case ds of wild { (,) index g' -> g' } #)) -}
0d06fbbbaa1290e8f6c8fa4e306a57fb
  $wbirdY :: (a -> a -> a) -> (GHC.Integer.Type.Integer -> a) -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,C(U)>, Inline: [2],
     Unfolding: (\ @ a
                   (ww :: a -> a -> a)
                   (ww1 :: GHC.Integer.Type.Integer -> a) ->
                 ww
                   (ww1 StreetRun.Engine.Obstacle.birdY2)
                   (ww1 StreetRun.Engine.Obstacle.birdY1)) -}
9f0794044af3e60bc0f6840b3f4430f5
  $wgo ::
    GHC.Prim.Int#
    -> (# StreetRun.Engine.Obstacle.ObstacleTag,
          [StreetRun.Engine.Obstacle.ObstacleTag] #)
  {- Arity: 1, Strictness: <L,U>, Inline: [2] -}
19ea1ecee7dc055dd9fa5102d95c8d9b
  $wgo1 ::
    [StreetRun.Engine.Obstacle.ObstacleState]
    -> (# [StreetRun.Engine.Obstacle.ObstacleState],
          [StreetRun.Engine.Obstacle.ObstacleState] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
16b4ce147843466afa7305b0cc573db9
  $wgo2 ::
    [StreetRun.Engine.Obstacle.ObstacleState]
    -> GHC.Prim.Float# -> GHC.Prim.Float#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>, Inline: [2] -}
0a9f52e0fae03498dcf74310fe73275f
  $witerateObstacles ::
    [(GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)]
    -> StreetRun.Engine.Types.Percent
    -> [StreetRun.Engine.Obstacle.ObstacleState]
    -> (# [StreetRun.Engine.Obstacle.ObstacleState], GHC.Types.Int,
          [(GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)],
          GHC.Maybe.Maybe StreetRun.Engine.Obstacle.ObstacleTag #)
  {- Arity: 3, Strictness: <L,U><L,1*U(U)><L,1*U>, Inline: [2],
     Unfolding: (\ (w :: [(GHC.Types.Int,
                           StreetRun.Engine.Obstacle.ObstacleTag)])
                   (w1 :: StreetRun.Engine.Types.Percent)
                   (w2 :: [StreetRun.Engine.Obstacle.ObstacleState]) ->
                 let {
                   ds :: ([StreetRun.Engine.Obstacle.ObstacleState],
                          [StreetRun.Engine.Obstacle.ObstacleState])
                   = case StreetRun.Engine.Obstacle.$wgo1
                            (StreetRun.Engine.Obstacle.stepObstacles
                               (case w1
                                       `cast`
                                     (StreetRun.Engine.Types.N:Percent[0]) of ww { GHC.Types.F# ww1 ->
                                case GHC.Float.$w$ctoRational1 ww1 of ww2 { (#,#) ww3 ww4 ->
                                (GHC.Float.rationalToFloat ww3 ww4)
                                  `cast`
                                (Sym (StreetRun.Engine.Types.N:Distance[0])) } })
                               w2) of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 let {
                   remained :: [StreetRun.Engine.Obstacle.ObstacleState]
                   = case ds of wild { (,) removed remained1 -> remained1 }
                 } in
                 let {
                   newObstacle :: GHC.Maybe.Maybe
                                    (StreetRun.Engine.Obstacle.ObstacleTag,
                                     StreetRun.Engine.Obstacle.ObstacleState)
                   = case StreetRun.Engine.Obstacle.iterateObstacles1 of ww { GHC.Types.F# ww1 ->
                     let {
                       $j :: GHC.Prim.Float#
                             -> GHC.Maybe.Maybe
                                  (StreetRun.Engine.Obstacle.ObstacleTag,
                                   StreetRun.Engine.Obstacle.ObstacleState)
                         <join 1> {- Arity: 1, Strictness: <S,U> -}
                       = \ (x :: GHC.Prim.Float#)[OneShot] ->
                         case StreetRun.Engine.Obstacle.canAddObstacle1
                                `cast`
                              (StreetRun.Engine.Types.N:Distance[0]) of wild1 { GHC.Types.F# y ->
                         case GHC.Prim.ltFloat# x y of lwild {
                           DEFAULT
                           -> GHC.Maybe.Nothing
                                @ (StreetRun.Engine.Obstacle.ObstacleTag,
                                   StreetRun.Engine.Obstacle.ObstacleState)
                           1#
                           -> let {
                                pair :: (GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)
                                = case w of wild {
                                    []
                                    -> GHC.List.badHead
                                         @ (GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)
                                    : x1 ds1 -> x1 }
                              } in
                              GHC.Maybe.Just
                                @ (StreetRun.Engine.Obstacle.ObstacleTag,
                                   StreetRun.Engine.Obstacle.ObstacleState)
                                (Data.Tuple.snd
                                   @ GHC.Types.Int
                                   @ StreetRun.Engine.Obstacle.ObstacleTag
                                   pair,
                                 StreetRun.Engine.Obstacle.placeObstacle pair) } }
                     } in
                     letrec {
                       $wgo3 :: [StreetRun.Engine.Obstacle.ObstacleState]
                                -> GHC.Prim.Float#
                                -> GHC.Maybe.Maybe
                                     (StreetRun.Engine.Obstacle.ObstacleTag,
                                      StreetRun.Engine.Obstacle.ObstacleState)
                         <join 2> {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [2] -}
                       = \ (w3 :: [StreetRun.Engine.Obstacle.ObstacleState])
                           (ww2 :: GHC.Prim.Float#) ->
                         case w3 of wild {
                           [] -> $j ww2
                           : y ys
                           -> case y of wild1 { StreetRun.Engine.Obstacle.ObstacleState ds1 ds2 ->
                              case ds2
                                     `cast`
                                   (StreetRun.Engine.Types.N:Distance[0]) of wild2 { GHC.Types.F# y1 ->
                              case GHC.Prim.leFloat# ww2 y1 of lwild {
                                DEFAULT -> $wgo3 ys ww2 1# -> $wgo3 ys y1 } } } }
                     } in
                     $wgo3 remained ww1 }
                 } in
                 let {
                   ds1 :: ([(GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)],
                           [StreetRun.Engine.Obstacle.ObstacleState])
                   = case newObstacle of wild {
                       GHC.Maybe.Nothing -> (w, remained)
                       GHC.Maybe.Just a1
                       -> (GHC.List.tail
                             @ (GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)
                             w,
                           GHC.Types.:
                             @ StreetRun.Engine.Obstacle.ObstacleState
                             (Data.Tuple.snd
                                @ StreetRun.Engine.Obstacle.ObstacleTag
                                @ StreetRun.Engine.Obstacle.ObstacleState
                                a1)
                             remained) }
                 } in
                 (# case ds1 of wild { (,) upcomingObstacles' obstacles' ->
                    obstacles' },
                    case ds of wild { (,) removed remained1 ->
                    case GHC.List.$wlenAcc
                           @ StreetRun.Engine.Obstacle.ObstacleState
                           removed
                           0# of ww2 { DEFAULT ->
                    GHC.Types.I# ww2 } },
                    case ds1 of wild { (,) upcomingObstacles' obstacles' ->
                    upcomingObstacles' },
                    case newObstacle of wild {
                      GHC.Maybe.Nothing
                      -> GHC.Maybe.Nothing @ StreetRun.Engine.Obstacle.ObstacleTag
                      GHC.Maybe.Just a1
                      -> GHC.Maybe.Just
                           @ StreetRun.Engine.Obstacle.ObstacleTag
                           (Data.Tuple.fst
                              @ StreetRun.Engine.Obstacle.ObstacleTag
                              @ StreetRun.Engine.Obstacle.ObstacleState
                              a1) } #)) -}
ac28cbe88be38f625619d07a30e0825e
  $wlavaY :: (a -> a -> a) -> (GHC.Integer.Type.Integer -> a) -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,C(U)>, Inline: [2],
     Unfolding: (\ @ a
                   (ww :: a -> a -> a)
                   (ww1 :: GHC.Integer.Type.Integer -> a) ->
                 ww
                   (ww1 StreetRun.Engine.Obstacle.birdY2)
                   (ww1 StreetRun.Engine.Obstacle.lavaY1)) -}
9f0794044af3e60bc0f6840b3f4430f5
  $wlvl :: GHC.Prim.Int# -> StreetRun.Engine.Obstacle.ObstacleTag
  {- Arity: 1, Strictness: <B,U>x, Inline: [2] -}
109994e34e811c3426f26f546e1f930f
  $wobstacleAabb ::
    StreetRun.Engine.Obstacle.ObstacleInfo
    -> StreetRun.Engine.Types.Distance
    -> (# Linear.V2.V2 GHC.Types.Float, Linear.V2.V2 GHC.Types.Float #)
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: StreetRun.Engine.Obstacle.ObstacleInfo)
                   (ww1 :: StreetRun.Engine.Types.Distance) ->
                 let {
                   dist :: GHC.Types.Float
                   = case ww1
                            `cast`
                          (StreetRun.Engine.Types.N:Distance[0]) of ww2 { GHC.Types.F# ww3 ->
                     case GHC.Float.$w$ctoRational1 ww3 of ww4 { (#,#) ww5 ww6 ->
                     GHC.Float.rationalToFloat ww5 ww6 } }
                 } in
                 case ww of wild {
                   StreetRun.Engine.Obstacle.ObstacleInfo'Lava ds
                   -> (# case dist of dt { GHC.Types.F# ipv ->
                         Linear.V2.V2
                           @ GHC.Types.Float
                           dt
                           StreetRun.Engine.Obstacle.lavaY_$slavaY },
                         case dist of wild1 { GHC.Types.F# y ->
                         Linear.V2.V2
                           @ GHC.Types.Float
                           (GHC.Types.F# (GHC.Prim.plusFloat# 32.0# y))
                           StreetRun.Engine.Obstacle.obstacleAabb3 } #)
                   StreetRun.Engine.Obstacle.ObstacleInfo'Rock ds
                   -> (# case dist of dt { GHC.Types.F# ipv ->
                         Linear.V2.V2
                           @ GHC.Types.Float
                           dt
                           StreetRun.Engine.Obstacle.obstacleAabb_$srockY },
                         case dist of wild1 { GHC.Types.F# y ->
                         Linear.V2.V2
                           @ GHC.Types.Float
                           (GHC.Types.F# (GHC.Prim.plusFloat# 32.0# y))
                           StreetRun.Engine.Obstacle.obstacleAabb2 } #)
                   StreetRun.Engine.Obstacle.ObstacleInfo'Bird ds
                   -> (# case dist of dt { GHC.Types.F# ipv ->
                         Linear.V2.V2
                           @ GHC.Types.Float
                           dt
                           StreetRun.Engine.Obstacle.birdY_$sbirdY },
                         case dist of wild1 { GHC.Types.F# y ->
                         Linear.V2.V2
                           @ GHC.Types.Float
                           (GHC.Types.F# (GHC.Prim.plusFloat# 32.0# y))
                           StreetRun.Engine.Obstacle.obstacleAabb1 } #) }) -}
58117e9caa091b29ffe97a76582ee103
  $wrandomRBoundedEnum ::
    (GHC.Enum.Bounded a, GHC.Enum.Enum a, System.Random.RandomGen g) =>
    a -> a -> g -> (# a, g #)
  {- Arity: 6,
     Strictness: <L,U(1*U,1*U)><L,U(A,A,A,C(U(U)),A,A,1*C1(C1(U)),A)><L,U(C(U(1*U(U),U)),C(U(U(U),1*U(U))),A)><L,U><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ @ a
                   @ g
                   (w :: GHC.Enum.Bounded a)
                   (w1 :: GHC.Enum.Enum a)
                   (w2 :: System.Random.RandomGen g)
                   (ww :: a)
                   (ww1 :: a)
                   (w3 :: g) ->
                 let {
                   ds :: (GHC.Types.Int, g)
                   = case GHC.Enum.fromEnum @ a w1 ww of wild { GHC.Types.I# i ->
                     case GHC.Enum.fromEnum @ a w1 ww1 of wild1 { GHC.Types.I# i1 ->
                     case System.Random.$wrandomIvalInteger
                            @ g
                            @ GHC.Types.Int
                            w2
                            GHC.Num.$fNumInt
                            (GHC.Integer.Type.smallInteger i)
                            (GHC.Integer.Type.smallInteger i1)
                            w3 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4) } } }
                 } in
                 (# let {
                      lastEnum :: a = GHC.Enum.maxBound @ a w
                    } in
                    case GHC.Enum.fromEnum @ a w1 lastEnum of wild { GHC.Types.I# x ->
                    case x of lwild {
                      DEFAULT
                      -> case ds of wild1 { (,) index g' ->
                         case index of wild2 { GHC.Types.I# x1 ->
                         case GHC.Classes.modInt#
                                x1
                                (GHC.Prim.+# lwild 1#) of ww2 { DEFAULT ->
                         GHC.List.$w!!
                           @ a
                           (GHC.Enum.enumFromTo @ a w1 (GHC.Enum.minBound @ a w) lastEnum)
                           ww2 } } }
                      -2#
                      -> GHC.List.$w!!
                           @ a
                           (GHC.Enum.enumFromTo @ a w1 (GHC.Enum.minBound @ a w) lastEnum)
                           0#
                      -1# -> case GHC.Real.divZeroError ret_ty a of {} } },
                    case ds of wild { (,) index g' -> g' } #)) -}
e153a76de13e3842443a0eedd67837f4
  $wrockY ::
    (a -> a -> a)
    -> (a -> a -> a) -> (GHC.Integer.Type.Integer -> a) -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,C(U)>,
     Inline: [2],
     Unfolding: (\ @ a
                   (ww :: a -> a -> a)
                   (ww1 :: a -> a -> a)
                   (ww2 :: GHC.Integer.Type.Integer -> a) ->
                 ww
                   (ww1
                      (ww2 StreetRun.Engine.Obstacle.birdY2)
                      (ww2 StreetRun.Engine.Obstacle.rockY1))
                   (ww2 StreetRun.Engine.Obstacle.$fRandomObstacleTag4)) -}
f6665f768a185efa1963b032d0785cae
  data ObstacleInfo
    = ObstacleInfo'Lava (Animate.Position
                           StreetRun.Engine.Lava.LavaKey StreetRun.Engine.Types.Seconds)
    | ObstacleInfo'Rock (Animate.Position
                           StreetRun.Engine.Rock.RockKey StreetRun.Engine.Types.Seconds)
    | ObstacleInfo'Bird (Animate.Position
                           StreetRun.Engine.Bird.BirdKey StreetRun.Engine.Types.Seconds)
0555b6400d2d8ceda49d732d4b2684e8
  data ObstacleState
    = ObstacleState {osInfo :: StreetRun.Engine.Obstacle.ObstacleInfo,
                     osDistance :: StreetRun.Engine.Types.Distance}
9f0794044af3e60bc0f6840b3f4430f5
  data ObstacleTag
    = ObstacleTag'Lava | ObstacleTag'Rock | ObstacleTag'Bird
f2e105988cf170a8a0fce726905f6550
  birdY :: GHC.Num.Num a => a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,C(U))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: GHC.Num.Num a) ->
                 case w of ww { GHC.Num.C:Num ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 StreetRun.Engine.Obstacle.$wbirdY @ a ww3 ww7 }) -}
f042e4ef2f44a1b6c44177af094f8a6a
  birdY1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (22) -}
8faa4c26da1ae730f7155444475bc0d8
  birdY2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (16) -}
944bf189057d64d7a7757dff16f46f91
  birdY_$sbirdY :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 352.0#) -}
d2d60abcc7bd7491ada88a7597939d2a
  canAddObstacle :: StreetRun.Engine.Types.Distance -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(S),1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (dist :: StreetRun.Engine.Types.Distance) ->
                 case dist
                        `cast`
                      (StreetRun.Engine.Types.N:Distance[0]) of wild { GHC.Types.F# x ->
                 case StreetRun.Engine.Obstacle.canAddObstacle1
                        `cast`
                      (StreetRun.Engine.Types.N:Distance[0]) of wild1 { GHC.Types.F# y ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.ltFloat# x y) } }) -}
ea3c784b9104e3db6017371ae0f98d4d
  canAddObstacle1 :: StreetRun.Engine.Types.Distance
  {- Unfolding: (case GHC.Float.$w$ctoRational1
                        1280.0# of ww2 { (#,#) ww3 ww4 ->
                 (GHC.Float.rationalToFloat ww3 ww4)
                   `cast`
                 (Sym (StreetRun.Engine.Types.N:Distance[0])) }) -}
f173fbfdbdeeea5f4b509b28e1894570
  iterateObstacles ::
    [(GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)]
    -> StreetRun.Engine.Types.Percent
    -> [StreetRun.Engine.Obstacle.ObstacleState]
    -> ([StreetRun.Engine.Obstacle.ObstacleState], GHC.Types.Int,
        [(GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)],
        GHC.Maybe.Maybe StreetRun.Engine.Obstacle.ObstacleTag)
  {- Arity: 3, Strictness: <L,U><L,1*U(U)><L,1*U>m, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: [(GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)])
                   (w1 :: StreetRun.Engine.Types.Percent)
                   (w2 :: [StreetRun.Engine.Obstacle.ObstacleState]) ->
                 case StreetRun.Engine.Obstacle.$witerateObstacles
                        w
                        w1
                        w2 of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                 (ww1, ww2, ww3, ww4) }) -}
c9dbd1e0d1e7df9224aaac39fc0d4fd4
  iterateObstacles1 :: GHC.Types.Float
  {- Unfolding: (case GHC.Float.$w$ctoRational1
                        1280.0# of ww2 { (#,#) ww3 ww4 ->
                 case GHC.Float.rationalToFloat ww3 ww4 of wild { GHC.Types.F# x ->
                 GHC.Types.F# (GHC.Prim.minusFloat# x 1.0#) } }) -}
b833c55c8ed8f2267171a99dddb4a7c6
  lastObstacleDistance ::
    [StreetRun.Engine.Obstacle.ObstacleState]
    -> StreetRun.Engine.Types.Distance
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [StreetRun.Engine.Obstacle.ObstacleState]) ->
                 case StreetRun.Engine.Obstacle.iterateObstacles1 of ww { GHC.Types.F# ww1 ->
                 case StreetRun.Engine.Obstacle.$wgo2 w ww1 of ww2 { DEFAULT ->
                 (GHC.Types.F# ww2)
                   `cast`
                 (Sym (StreetRun.Engine.Types.N:Distance[0])) } }) -}
69c3fd1b8884dafd49ec3121e639dfc7
  lavaY :: GHC.Num.Num a => a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,C(U))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: GHC.Num.Num a) ->
                 case w of ww { GHC.Num.C:Num ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 StreetRun.Engine.Obstacle.$wlavaY @ a ww3 ww7 }) -}
8e0fcb2344f9dbe0b3c4cc8fc0ded07d
  lavaY1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (28) -}
e390d6d8794b5a316ef7997bac8925f7
  lavaY_$slavaY :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 448.0#) -}
57fb38649c97d54254f212520704b3e7
  obstacleAabb ::
    StreetRun.Engine.Obstacle.ObstacleState
    -> StreetRun.Engine.Physics.Aabb
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,1*U(U))>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: StreetRun.Engine.Obstacle.ObstacleState) ->
                 case w of ww { StreetRun.Engine.Obstacle.ObstacleState ww1 ww2 ->
                 case StreetRun.Engine.Obstacle.$wobstacleAabb
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 StreetRun.Engine.Physics.Aabb ww4 ww5 } }) -}
11360743451511ded3f5baa069b54026
  obstacleAabb1 :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 384.0#) -}
e781673d2c6ecf0114be22876553084b
  obstacleAabb2 :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 450.0#) -}
09d0b24ff37dedd28522bebc1b612697
  obstacleAabb3 :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 480.0#) -}
c16c60f093b2dcb19155f0bd1919ad7a
  obstacleAabb_$srockY :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 418.0#) -}
e227b19c6470a0e5ac33e056cb074e43
  placeObstacle ::
    (GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)
    -> StreetRun.Engine.Obstacle.ObstacleState
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)) ->
                 case w of ww { (,) ww1 ww2 ->
                 StreetRun.Engine.Obstacle.ObstacleState
                   (case ww2 of wild {
                      StreetRun.Engine.Obstacle.ObstacleTag'Lava
                      -> StreetRun.Engine.Obstacle.placeObstacle6
                      StreetRun.Engine.Obstacle.ObstacleTag'Rock
                      -> StreetRun.Engine.Obstacle.placeObstacle4
                      StreetRun.Engine.Obstacle.ObstacleTag'Bird
                      -> StreetRun.Engine.Obstacle.placeObstacle1 })
                   (case ww1 of wild { GHC.Types.I# x ->
                    case GHC.Integer.Type.smallInteger
                           (GHC.Prim.*# x 32#) of dt { DEFAULT ->
                    case GHC.Float.rationalToFloat
                           dt
                           GHC.Real.$fEnumRatio1 of wild1 { GHC.Types.F# x1 ->
                    case StreetRun.Engine.Obstacle.canAddObstacle1
                           `cast`
                         (StreetRun.Engine.Types.N:Distance[0]) of wild2 { GHC.Types.F# y ->
                    (GHC.Types.F# (GHC.Prim.plusFloat# x1 y))
                      `cast`
                    (Sym (StreetRun.Engine.Types.N:Distance[0])) } } } }) }) -}
506542bc596bd8c43109040e502783f7
  placeObstacle1 :: StreetRun.Engine.Obstacle.ObstacleInfo
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (StreetRun.Engine.Obstacle.ObstacleInfo'Bird
                   StreetRun.Engine.Obstacle.placeObstacle2) -}
9a1bc95e275a1eabe95eea8b255e6e9a
  placeObstacle2 ::
    Animate.Position
      StreetRun.Engine.Bird.BirdKey StreetRun.Engine.Types.Seconds
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Animate.Position
                   @ StreetRun.Engine.Bird.BirdKey
                   @ StreetRun.Engine.Types.Seconds
                   StreetRun.Engine.Bird.BirdKey'Idle
                   Animate.$fShowAnimations1
                   StreetRun.Engine.Obstacle.placeObstacle3
                     `cast`
                   (Sym (StreetRun.Engine.Types.N:Seconds[0]))
                   Animate.Loop'Always) -}
4ddba289254166e0fe8af969a0692c7c
  placeObstacle3 :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 0.0#) -}
4a7d343b2373bd29359d05f2f2267df5
  placeObstacle4 :: StreetRun.Engine.Obstacle.ObstacleInfo
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (StreetRun.Engine.Obstacle.ObstacleInfo'Rock
                   StreetRun.Engine.Obstacle.placeObstacle5) -}
32c9b4a8863cd841777218300c940e66
  placeObstacle5 ::
    Animate.Position
      StreetRun.Engine.Rock.RockKey StreetRun.Engine.Types.Seconds
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Animate.Position
                   @ StreetRun.Engine.Rock.RockKey
                   @ StreetRun.Engine.Types.Seconds
                   StreetRun.Engine.Rock.RockKey'Idle
                   Animate.$fShowAnimations1
                   StreetRun.Engine.Obstacle.placeObstacle3
                     `cast`
                   (Sym (StreetRun.Engine.Types.N:Seconds[0]))
                   Animate.Loop'Always) -}
91cecf793501b84b529c82c52fc4cdeb
  placeObstacle6 :: StreetRun.Engine.Obstacle.ObstacleInfo
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (StreetRun.Engine.Obstacle.ObstacleInfo'Lava
                   StreetRun.Engine.Obstacle.placeObstacle7) -}
d4a43bde1c154c9543c4c4de6dd49654
  placeObstacle7 ::
    Animate.Position
      StreetRun.Engine.Lava.LavaKey StreetRun.Engine.Types.Seconds
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Animate.Position
                   @ StreetRun.Engine.Lava.LavaKey
                   @ StreetRun.Engine.Types.Seconds
                   StreetRun.Engine.Lava.LavaKey'Idle
                   Animate.$fShowAnimations1
                   StreetRun.Engine.Obstacle.placeObstacle3
                     `cast`
                   (Sym (StreetRun.Engine.Types.N:Seconds[0]))
                   Animate.Loop'Always) -}
86900ac8706be29b581510662b6f8ccc
  randomRBoundedEnum ::
    (GHC.Enum.Bounded a, GHC.Enum.Enum a, System.Random.RandomGen g) =>
    (a, a) -> g -> (a, g)
  {- Arity: 5,
     Strictness: <L,U(U,U)><L,U(A,A,A,C(U(U)),A,A,C(C1(U)),A)><L,U(C(U(1*U(U),U)),C(U(U(U),1*U(U))),A)><S,1*U(U,U)><L,U>m,
     Inline: [2],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ g
                   (w :: GHC.Enum.Bounded a)
                   (w1 :: GHC.Enum.Enum a)
                   (w2 :: System.Random.RandomGen g)
                   (w3 :: (a, a))
                   (w4 :: g) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 case StreetRun.Engine.Obstacle.$wrandomRBoundedEnum
                        @ a
                        @ g
                        w
                        w1
                        w2
                        ww1
                        ww2
                        w4 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5) } }) -}
f1d87e34e1833a51ccf742f556001f1f
  removeOutOfBoundObstacles ::
    [StreetRun.Engine.Obstacle.ObstacleState]
    -> ([StreetRun.Engine.Obstacle.ObstacleState],
        [StreetRun.Engine.Obstacle.ObstacleState])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [StreetRun.Engine.Obstacle.ObstacleState]) ->
                 case StreetRun.Engine.Obstacle.$wgo1 w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
7bd5889573aa4b9dcd2cb93f637b2152
  rockY :: GHC.Num.Num a => a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,1*C1(C1(U)),A,A,A,C(U))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: GHC.Num.Num a) ->
                 case w of ww { GHC.Num.C:Num ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 StreetRun.Engine.Obstacle.$wrockY @ a ww1 ww3 ww7 }) -}
3fe2e10a6c11c1be8331f1eb369e314c
  rockY1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (26) -}
3598a22e07fed97361f7f5000f62b7fb
  stepObstacles ::
    StreetRun.Engine.Types.Distance
    -> [StreetRun.Engine.Obstacle.ObstacleState]
    -> [StreetRun.Engine.Obstacle.ObstacleState]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,1*U>,
     Unfolding: (\ (delta :: StreetRun.Engine.Types.Distance)
                   (eta :: [StreetRun.Engine.Obstacle.ObstacleState]) ->
                 GHC.Base.map
                   @ StreetRun.Engine.Obstacle.ObstacleState
                   @ StreetRun.Engine.Obstacle.ObstacleState
                   (\ (o :: StreetRun.Engine.Obstacle.ObstacleState) ->
                    case o of wild { StreetRun.Engine.Obstacle.ObstacleState ds ds1 ->
                    StreetRun.Engine.Obstacle.ObstacleState
                      ds
                      (case ds1
                              `cast`
                            (StreetRun.Engine.Types.N:Distance[0]) of wild1 { GHC.Types.F# x ->
                       case ds of wild2 {
                         DEFAULT
                         -> case delta
                                   `cast`
                                 (StreetRun.Engine.Types.N:Distance[0]) of wild3 { GHC.Types.F# y ->
                            (GHC.Types.F# (GHC.Prim.minusFloat# x y))
                              `cast`
                            (Sym (StreetRun.Engine.Types.N:Distance[0])) }
                         StreetRun.Engine.Obstacle.ObstacleInfo'Bird ds2
                         -> case delta
                                   `cast`
                                 (StreetRun.Engine.Types.N:Distance[0]) of wild3 { GHC.Types.F# x1 ->
                            (GHC.Types.F#
                               (GHC.Prim.minusFloat# x (GHC.Prim.plusFloat# x1 4.0#)))
                              `cast`
                            (Sym (StreetRun.Engine.Types.N:Distance[0])) } } }) })
                   eta) -}
c10794b4111a86441fc90f26dcd72972
  streamOfObstacles ::
    System.Random.RandomGen g =>
    g -> [(GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)]
  {- Arity: 2,
     Strictness: <L,U(C(U(1*U(U),U)),C(U(U(U),1*U(U))),A)><L,U>,
     Unfolding: (\ @ g
                   ($dRandomGen :: System.Random.RandomGen g)
                   (g1 :: g) ->
                 letrec {
                   go :: g
                         -> [StreetRun.Engine.Obstacle.ObstacleTag]
                         -> [(GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)]
                     {- Arity: 2, Strictness: <L,U><S,1*U> -}
                   = \ (g2 :: g) (eta :: [StreetRun.Engine.Obstacle.ObstacleTag]) ->
                     case System.Random.$wrandomIvalInteger
                            @ g
                            @ GHC.Types.Int
                            $dRandomGen
                            GHC.Num.$fNumInt
                            System.Random.$fRandomCIntMax4
                            System.Random.$fRandomCIntMax3
                            g2 of ww3 { (#,#) ww4 ww5 ->
                     case ww4 of x1 { GHC.Types.I# ipv ->
                     case eta of wild {
                       []
                       -> GHC.Types.[]
                            @ (GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)
                       : y ys
                       -> GHC.Types.:
                            @ (GHC.Types.Int, StreetRun.Engine.Obstacle.ObstacleTag)
                            (case GHC.Classes.modInt# ipv 18# of ww2 { DEFAULT ->
                             GHC.Types.I# (GHC.Prim.+# ww2 3#) },
                             y)
                            (go ww5 ys) } } }
                 } in
                 letrec {
                   go1 :: g -> [StreetRun.Engine.Obstacle.ObstacleTag]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (g2 :: g) ->
                     case System.Random.$wrandomIvalInteger
                            @ g
                            @ GHC.Types.Int
                            $dRandomGen
                            GHC.Num.$fNumInt
                            StreetRun.Engine.Obstacle.$fRandomObstacleTag5
                            StreetRun.Engine.Obstacle.$fRandomObstacleTag4
                            g2 of ww2 { (#,#) ww3 ww4 ->
                     case ww3 of wild1 { GHC.Types.I# x ->
                     case GHC.Classes.modInt# x 3# of ww1 { DEFAULT ->
                     case GHC.List.$w!!
                            @ StreetRun.Engine.Obstacle.ObstacleTag
                            StreetRun.Engine.Obstacle.$fRandomObstacleTag3
                            ww1 of x1 { DEFAULT ->
                     GHC.Types.:
                       @ StreetRun.Engine.Obstacle.ObstacleTag
                       x1
                       (go1 ww4) } } } }
                 } in
                 go g1 (go1 g1)) -}
instance GHC.Enum.Bounded [StreetRun.Engine.Obstacle.ObstacleTag]
  = StreetRun.Engine.Obstacle.$fBoundedObstacleTag
instance GHC.Enum.Enum [StreetRun.Engine.Obstacle.ObstacleTag]
  = StreetRun.Engine.Obstacle.$fEnumObstacleTag
instance GHC.Classes.Eq [StreetRun.Engine.Obstacle.ObstacleInfo]
  = StreetRun.Engine.Obstacle.$fEqObstacleInfo
instance GHC.Classes.Eq [StreetRun.Engine.Obstacle.ObstacleState]
  = StreetRun.Engine.Obstacle.$fEqObstacleState
instance GHC.Classes.Eq [StreetRun.Engine.Obstacle.ObstacleTag]
  = StreetRun.Engine.Obstacle.$fEqObstacleTag
instance GHC.Classes.Ord [StreetRun.Engine.Obstacle.ObstacleTag]
  = StreetRun.Engine.Obstacle.$fOrdObstacleTag
instance System.Random.Random [StreetRun.Engine.Obstacle.ObstacleTag]
  = StreetRun.Engine.Obstacle.$fRandomObstacleTag
instance GHC.Show.Show [StreetRun.Engine.Obstacle.ObstacleInfo]
  = StreetRun.Engine.Obstacle.$fShowObstacleInfo
instance GHC.Show.Show [StreetRun.Engine.Obstacle.ObstacleState]
  = StreetRun.Engine.Obstacle.$fShowObstacleState
instance GHC.Show.Show [StreetRun.Engine.Obstacle.ObstacleTag]
  = StreetRun.Engine.Obstacle.$fShowObstacleTag
"SPEC birdY @ Float" forall ($dNum :: GHC.Num.Num GHC.Types.Float)
  StreetRun.Engine.Obstacle.birdY @ GHC.Types.Float $dNum
  = StreetRun.Engine.Obstacle.birdY_$sbirdY
"SPEC lavaY @ Float" forall ($dNum :: GHC.Num.Num GHC.Types.Float)
  StreetRun.Engine.Obstacle.lavaY @ GHC.Types.Float $dNum
  = StreetRun.Engine.Obstacle.lavaY_$slavaY
"SPEC rockY @ Float" forall ($dNum :: GHC.Num.Num GHC.Types.Float)
  StreetRun.Engine.Obstacle.rockY @ GHC.Types.Float $dNum
  = StreetRun.Engine.Obstacle.obstacleAabb_$srockY
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

