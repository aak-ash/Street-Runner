
==================== FINAL INTERFACE ====================
2019-04-26 14:29:00.948200433 UTC

interface street-runner-0.0.0-8ZEy2IVHyWYJYWzE7qtJkg:StreetRun.Input 8064
  interface hash: e12fa591a4160e1fb8a9fd40e231f3ef
  ABI hash: 2b2882bb9ccf0deac02d72ccd2af9474
  export-list hash: 794b8afcff1485016b9c41551ca5bab1
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: cd6997935d09daa6a687cb8eb0447281
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  StreetRun.Input.initInput
  StreetRun.Input.Input{StreetRun.Input.Input iDown iEscape iQuit iSpace iUp}
module dependencies:
package dependencies: base-4.12.0.0 ghc-prim-0.5.3
                      integer-gmp-1.0.2.0 key-state-0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity base-4.12.0.0:Data.Monoid
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:GHC.Generics
                         base-4.12.0.0:GHC.IO.Exception
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Show 838a5d039379d82d9626aae53dfce276
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
import  -/  key-state-0.2.0:KeyState f505d200ccd373546afa68666240df7e
f50c2ab9e2082623275c9cc57e0e92df
  $fEqInput :: GHC.Classes.Eq StreetRun.Input.Input
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ StreetRun.Input.Input
                  StreetRun.Input.$fEqInput_$c==
                  StreetRun.Input.$fEqInput_$c/= -}
f50c2ab9e2082623275c9cc57e0e92df
  $fEqInput_$c/= ::
    StreetRun.Input.Input -> StreetRun.Input.Input -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SL)LLLL),1*U(1*U(1*U,1*U),1*U(1*U,1*U),1*U(1*U,1*U),1*U(1*U,1*U),1*U)><S(S(SL)LLLL),1*U(1*U(1*U,1*U),1*U(1*U,1*U),1*U(1*U,1*U),1*U(1*U,1*U),1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: StreetRun.Input.Input) (y :: StreetRun.Input.Input) ->
                 case StreetRun.Input.$fEqInput_$c== x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
f50c2ab9e2082623275c9cc57e0e92df
  $fEqInput_$c== ::
    StreetRun.Input.Input -> StreetRun.Input.Input -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SL)LLLL),1*U(1*U(1*U,1*U),1*U(1*U,1*U),1*U(1*U,1*U),1*U(1*U,1*U),1*U)><S(S(SL)LLLL),1*U(1*U(1*U,1*U),1*U(1*U,1*U),1*U(1*U,1*U),1*U(1*U,1*U),1*U)>,
     Unfolding: (\ (ds :: StreetRun.Input.Input)
                   (ds1 :: StreetRun.Input.Input) ->
                 case ds of wild { StreetRun.Input.Input a1 a2 a3 a4 a5 ->
                 case ds1 of wild1 { StreetRun.Input.Input b1 b2 b3 b4 b5 ->
                 case a1 of ww { KeyState.KeyState ww1 ww2 ->
                 case b1 of ww3 { KeyState.KeyState ww4 ww5 ->
                 case KeyState.$w$c==
                        @ GHC.Types.Int
                        GHC.Classes.$fEqInt
                        ww1
                        ww2
                        ww4
                        ww5 of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case a2 of ww7 { KeyState.KeyState ww8 ww9 ->
                      case b2 of ww10 { KeyState.KeyState ww11 ww12 ->
                      case KeyState.$w$c==
                             @ GHC.Types.Int
                             GHC.Classes.$fEqInt
                             ww8
                             ww9
                             ww11
                             ww12 of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case a3 of ww13 { KeyState.KeyState ww14 ww15 ->
                           case b3 of ww16 { KeyState.KeyState ww17 ww18 ->
                           case KeyState.$w$c==
                                  @ GHC.Types.Int
                                  GHC.Classes.$fEqInt
                                  ww14
                                  ww15
                                  ww17
                                  ww18 of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case a4 of ww19 { KeyState.KeyState ww20 ww21 ->
                                case b4 of ww22 { KeyState.KeyState ww23 ww24 ->
                                case KeyState.$w$c==
                                       @ GHC.Types.Int
                                       GHC.Classes.$fEqInt
                                       ww20
                                       ww21
                                       ww23
                                       ww24 of wild5 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> GHC.Classes.$fEqBool_$c== a5 b5 } } } } } } } } } } } } } }) -}
f50c2ab9e2082623275c9cc57e0e92df
  $fShowInput :: GHC.Show.Show StreetRun.Input.Input
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ StreetRun.Input.Input
                  StreetRun.Input.$fShowInput_$cshowsPrec
                  StreetRun.Input.$fShowInput_$cshow
                  StreetRun.Input.$fShowInput_$cshowList -}
f50c2ab9e2082623275c9cc57e0e92df
  $fShowInput1 :: StreetRun.Input.Input -> GHC.Show.ShowS
  {- Arity: 1,
     Strictness: <S,1*U(1*U(U,1*U),1*U(U,1*U),1*U(U,1*U),1*U(U,1*U),U)>,
     Unfolding: (\ (w :: StreetRun.Input.Input) ->
                 case w of ww { StreetRun.Input.Input ww1 ww2 ww3 ww4 ww5 ->
                 StreetRun.Input.$w$cshowsPrec 0# ww1 ww2 ww3 ww4 ww5 }) -}
996e2650419b780494b6ce23fecbbe11
  $fShowInput2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
f50c2ab9e2082623275c9cc57e0e92df
  $fShowInput_$cshow :: StreetRun.Input.Input -> GHC.Base.String
  {- Arity: 1,
     Strictness: <S,1*U(1*U(U,1*U),1*U(U,1*U),1*U(U,1*U),1*U(U,1*U),U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: StreetRun.Input.Input) ->
                 StreetRun.Input.$fShowInput_$cshowsPrec
                   StreetRun.Input.$fShowInput2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f50c2ab9e2082623275c9cc57e0e92df
  $fShowInput_$cshowList :: [StreetRun.Input.Input] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [StreetRun.Input.Input]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ StreetRun.Input.Input
                   StreetRun.Input.$fShowInput1
                   ls
                   s) -}
f50c2ab9e2082623275c9cc57e0e92df
  $fShowInput_$cshowsPrec ::
    GHC.Types.Int -> StreetRun.Input.Input -> GHC.Show.ShowS
  {- Arity: 2,
     Strictness: <S(S),1*U(U)><S,1*U(1*U(U,1*U),1*U(U,1*U),1*U(U,1*U),1*U(U,1*U),U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: StreetRun.Input.Input) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { StreetRun.Input.Input ww3 ww4 ww5 ww6 ww7 ->
                 StreetRun.Input.$w$cshowsPrec ww1 ww3 ww4 ww5 ww6 ww7 } }) -}
f50c2ab9e2082623275c9cc57e0e92df
  $sel:iDown:Input ::
    StreetRun.Input.Input -> KeyState.KeyState GHC.Types.Int
  RecSel Left StreetRun.Input.Input
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLL),1*U(A,A,1*U(U,U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: StreetRun.Input.Input) ->
                 case ds of wild { StreetRun.Input.Input ds1 ds2 ds3 ds4 ds5 ->
                 ds3 }) -}
f50c2ab9e2082623275c9cc57e0e92df
  $sel:iEscape:Input ::
    StreetRun.Input.Input -> KeyState.KeyState GHC.Types.Int
  RecSel Left StreetRun.Input.Input
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSL),1*U(A,A,A,1*U(U,U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: StreetRun.Input.Input) ->
                 case ds of wild { StreetRun.Input.Input ds1 ds2 ds3 ds4 ds5 ->
                 ds4 }) -}
f50c2ab9e2082623275c9cc57e0e92df
  $sel:iQuit:Input :: StreetRun.Input.Input -> GHC.Types.Bool
  RecSel Left StreetRun.Input.Input
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLLS),1*U(A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: StreetRun.Input.Input) ->
                 case ds of wild { StreetRun.Input.Input ds1 ds2 ds3 ds4 ds5 ->
                 ds5 }) -}
f50c2ab9e2082623275c9cc57e0e92df
  $sel:iSpace:Input ::
    StreetRun.Input.Input -> KeyState.KeyState GHC.Types.Int
  RecSel Left StreetRun.Input.Input
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(U,U),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: StreetRun.Input.Input) ->
                 case ds of wild { StreetRun.Input.Input ds1 ds2 ds3 ds4 ds5 ->
                 ds1 }) -}
f50c2ab9e2082623275c9cc57e0e92df
  $sel:iUp:Input ::
    StreetRun.Input.Input -> KeyState.KeyState GHC.Types.Int
  RecSel Left StreetRun.Input.Input
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLL),1*U(A,1*U(U,U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: StreetRun.Input.Input) ->
                 case ds of wild { StreetRun.Input.Input ds1 ds2 ds3 ds4 ds5 ->
                 ds2 }) -}
1ed61cded2861258f09b740744487fe5
  $tc'Input :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4299936760947063665##
                   10561969034365961826##
                   StreetRun.Input.$trModule
                   StreetRun.Input.$tc'Input2
                   0#
                   StreetRun.Input.$tc'Input1) -}
c4f1cc7bb7b559b77544ba613b7dbcfb
  $tc'Input1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
035eaa4dd32375b4c19637c227910fe2
  $tc'Input2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS StreetRun.Input.$tc'Input3) -}
6a09dac42dac19529fbc345554a4e320
  $tc'Input3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Input"#) -}
f7e00621505718ee15680da3e9ffc8bb
  $tcInput :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   834930815167070892##
                   416939108165476731##
                   StreetRun.Input.$trModule
                   StreetRun.Input.$tcInput1
                   0#
                   GHC.Types.krep$*) -}
d3c70589fd51cdf1c33193fbbd405371
  $tcInput1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS StreetRun.Input.$tcInput2) -}
7b2e2e70b80ffe99ef5725237bc2314c
  $tcInput2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Input"#) -}
085f4aebbcdd7ce219b9f399eba34976
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   StreetRun.Input.$trModule3
                   StreetRun.Input.$trModule1) -}
e9418c5736b0a665f0b051b410d64371
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS StreetRun.Input.$trModule2) -}
677b92d442bff0e6235cd1e8e483c82f
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("StreetRun.Input"#) -}
86626b2959a8374d26393bd3f6495ffd
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS StreetRun.Input.$trModule4) -}
41149b8db604dcdd06f699f64d3ff8c7
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("street-runner-0.0.0-8ZEy2IVHyWYJYWzE7qtJkg"#) -}
7396f308defe52cf6968bda207aa2848
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> KeyState.KeyState GHC.Types.Int
    -> KeyState.KeyState GHC.Types.Int
    -> KeyState.KeyState GHC.Types.Int
    -> KeyState.KeyState GHC.Types.Int
    -> GHC.Types.Bool
    -> GHC.Show.ShowS
  {- Arity: 6,
     Strictness: <S,U><L,1*U(U,1*U)><L,1*U(U,1*U)><L,1*U(U,1*U)><L,1*U(U,1*U)><L,U>,
     Inline: [2] -}
f50c2ab9e2082623275c9cc57e0e92df
  data Input
    = Input {iSpace :: KeyState.KeyState GHC.Types.Int,
             iUp :: KeyState.KeyState GHC.Types.Int,
             iDown :: KeyState.KeyState GHC.Types.Int,
             iEscape :: KeyState.KeyState GHC.Types.Int,
             iQuit :: GHC.Types.Bool}
5f2bfd4a976eb5bf95386ec47a194730
  initInput :: StreetRun.Input.Input
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (StreetRun.Input.Input
                   (KeyState.initKeyState @ GHC.Types.Int)
                   (KeyState.initKeyState @ GHC.Types.Int)
                   (KeyState.initKeyState @ GHC.Types.Int)
                   (KeyState.initKeyState @ GHC.Types.Int)
                   GHC.Types.False) -}
instance GHC.Classes.Eq [StreetRun.Input.Input]
  = StreetRun.Input.$fEqInput
instance GHC.Show.Show [StreetRun.Input.Input]
  = StreetRun.Input.$fShowInput
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

